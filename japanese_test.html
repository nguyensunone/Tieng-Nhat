<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>English Practice</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;600&display=swap" rel="stylesheet">
  <style>
    /* VS Code Dark+ inspired palette */
    :root {
      --page-bg-color: #1e1e1e;
      --bg: linear-gradient(180deg,#1e1e1e 0%, #181818 100%);
      --card-bg: #252526;
      --text: #d4d4d4;
      --muted: #9a9a9a;
      --primary: #569cd6; /* VSCode blue */
      --accent: #c586c0;  /* VSCode purple */
      --success: #6a9955;
      --error: #f44747;
      --glass: rgba(255,255,255,0.02);
      --shadow: 0 10px 26px rgba(0,0,0,0.6);
      --soft-shadow: 0 6px 14px rgba(0,0,0,0.5);
      --border: rgba(255,255,255,0.02);
      --radius: 12px;
    }
    /* light theme kept but tuned to be less bright and more contrasted */
    [data-theme="light"] {
      --page-bg-color: #f4f7fc;
      --bg: linear-gradient(180deg,#f6f9ff 0%, #eef6ff 100%);
      --card-bg: rgba(255,255,255,0.98);
      --text: #0f1724;
      --muted: #51637a;
      --primary: #2563eb;
      --accent: #7c3aed;
      --shadow: 0 12px 30px rgba(20,35,80,0.08);
      --soft-shadow: 0 6px 18px rgba(20,35,80,0.04);
      --border: rgba(16,24,40,0.06);
      --radius: 12px;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: 'Poppins', sans-serif; color: var(--text); background: var(--bg); min-height: 100vh; scroll-behavior: smooth; }
    .container { max-width: 1100px; margin: 36px auto; padding: 20px; }
    header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 24px; }
    .logo { width: 52px; height: 52px; background: linear-gradient(135deg, var(--primary), var(--accent)); border-radius: 12px; display: flex; align-items: center; justify-content: center; color: #071022; font-weight: 800; font-size: 1.1rem; box-shadow: var(--soft-shadow); }
    
    .control-panel { 
      display: flex; flex-wrap: wrap; gap: 8px; background: var(--card-bg);
      padding: 6px 8px; border-radius: calc(var(--radius) - 4px); box-shadow: var(--soft-shadow); margin-bottom: 12px; align-items: center; border: 1px solid rgba(255,255,255,0.03);
      font-size: 0.88rem; line-height: 1; 
      position: -webkit-sticky; position: sticky; top: 20px; z-index: 55;
    }
    .option-group { display: flex; align-items: center; gap: 8px; font-weight: 600; font-size: 0.86rem; border-right: 1px solid var(--border); padding-right: 8px; }
    .option-group:last-child { border-right: none; }
    
    select { flex: 1; min-width: 180px; padding: 10px 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.03); background: var(--card-bg); color: var(--text); font-weight: 600; outline: none; box-shadow: none; }
    .btn { border: none; border-radius: 8px; padding: 10px 16px; font-weight: 700; cursor: pointer; transition: all 0.12s ease; background: linear-gradient(90deg,var(--primary),#4fc3f7); color: #0b1220; box-shadow: 0 6px 18px rgba(0,0,0,0.6); }
    .btn:hover { transform: translateY(-1px); box-shadow: 0 10px 26px rgba(0,0,0,0.6); }
    .btn.ghost { background: transparent; border: 1px solid rgba(255,255,255,0.04); color: var(--primary); box-shadow: none; font-weight:700; }
    .btn.active-mode { background: linear-gradient(90deg,var(--success),#12c07a); color: white; }
    .btn.speaking-on { background: linear-gradient(90deg,#ff7a00,#ffb86b); color: white; box-shadow: 0 8px 28px rgba(255,124,0,0.18); }
    
    .exercise-item { background: var(--card-bg); padding: 26px; border-radius: var(--radius); box-shadow: var(--shadow); margin-bottom: 20px; border: 1px solid var(--border); animation: fadeIn 0.36s ease; }
    @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
    
    .question { font-size: 1.18rem; font-weight: 700; margin-bottom: 10px; color: #2563EB; letter-spacing: 0.2px; }
    .vietnamese { font-style: italic; color: #12C07A; margin-bottom: 15px; }
    .translation-hint { color: #C586C0; font-weight: 600; font-style: italic; display: block; margin-top: 8px; font-size: 0.95rem; }
    
    /* Utility classes matching the three-line color scheme from the screenshot */
    .title { color: #2563EB; font-weight: 800; font-size: 2rem; line-height: 1.05; }
    .ipa { color: #C586C0; font-style: normal; font-size: 1.1rem; display: block; margin-top: 6px; }
    .vn { color: #12C07A; font-style: italic; font-size: 1rem; display: block; margin-top: 6px; }
    input[type="text"] { width: 100%; padding: 12px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.03); background: var(--card-bg); color: var(--text); font-size: 1.02rem; outline: none; transition: 0.18s; box-shadow: none; }
    input:focus { border-color: var(--primary); background: var(--card-bg); transform: translateY(-1px); }
    
    .feedback { margin-top: 15px; padding: 12px; border-radius: 8px; min-height: 20px; font-weight: 600; line-height: 1.5; }
    .feedback.success { color: var(--success); background: rgba(46, 204, 113, 0.1); }
    .feedback.error { color: var(--error); background: rgba(231, 76, 60, 0.1); }
    
    .tabs { display: flex; gap: 12px; margin-bottom: 20px; }
    .tab { padding: 10px 18px; border-radius: 12px; cursor: pointer; background: transparent; border: 1px solid transparent; color: var(--text); opacity:0.92; font-weight: 700; transition: all 0.12s ease; }
    .tab:hover { color: var(--text); transform: translateY(-2px); }
    .tab.active { background: linear-gradient(90deg,var(--primary),var(--accent)); color: white; border-color: transparent; box-shadow: 0 10px 30px rgba(37,99,235,0.12); }
    
    .pagination { display: flex; justify-content: center; align-items: center; gap: 20px; margin-top: 10px; padding-bottom: 40px; }
    
    #backToTop {
      position: fixed; bottom: 30px; right: 30px; width: 50px; height: 50px;
      background: var(--primary); color: white; border-radius: 50%;
      display: flex; align-items: center; justify-content: center;
      cursor: pointer; box-shadow: var(--shadow); border: none;
      opacity: 0; visibility: hidden; transition: 0.3s; z-index: 1000; font-size: 1.2rem;
    }
    #backToTop.show { opacity: 1; visibility: visible; }
    .hide { display: none; }

    /* Per-mode controls removed ‚Äî use the unified #tabControlBar instead */
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
</head>
<body data-theme="light">
  <div class="container">
    <header>
      <div style="display:flex; align-items:center; gap:12px">
        <div class="logo">4S</div>
        <div>
          <h1 style="margin:0; font-size: 1.5rem;">Conversation Practice</h1>
          <p style="margin:0; font-size: 0.8rem; color: var(--text);">Listen - Speak - Read - Write</p>
        </div>
      </div>
      <div style="display:flex; gap:10px; align-items:center">
        <!-- Import JSON removed; lessons are loaded from json_list.json / LESSON/ -->
        <button class="btn ghost" id="themeToggle" title="Chuy·ªÉn giao di·ªán s√°ng/t·ªëi">üåô</button>
        <a class="btn ghost" href="test_offline.html" title="M·ªü H·ªçc Ngo·∫°i Ng·ªØ" style="margin-left:6px">H·ªçc Ngo·∫°i Ng·ªØ</a>
      </div>
    </header>

    <div class="tabs">
      <button class="tab active" id="tabListeningPreview" title="Ch·∫ø ƒë·ªô: Listening Preview">Listening Preview</button>
      <button class="tab" id="tabReading" title="Ch·∫ø ƒë·ªô: B√†i ƒë·ªçc (Reading Test)">Reading Test</button>
      <button class="tab" id="tabSentence" title="Ch·∫ø ƒë·ªô: Vi·∫øt c√¢u (Writing Test)">Writing Test</button>
      <button class="tab" id="tabDictation" title="Ch·∫ø ƒë·ªô: Dictation">Dictation</button>
      <button class="tab" id="tabRolePlaying" title="Role Playing">Role Playing</button>
    </div>

    <!-- Unified control bar: keeps main playback/navigation buttons consistent across tabs -->
    <div id="tabControlBar" class="control-panel" style="margin-bottom:14px;">
      <div style="display:flex; gap:8px; align-items:center; width:100%; justify-content:center; flex-wrap:wrap">
        <button class="btn ghost" id="centralPrev" title="Tr∆∞·ªõc">‚óÄ Tr∆∞·ªõc</button>
        
        <button class="btn ghost" id="centralRestart" title="B·∫Øt ƒë·∫ßu l·∫°i">üîÅ B·∫Øt ƒë·∫ßu l·∫°i</button>
        <button class="btn" id="centralPlay" title="Ph√°t / D·ª´ng">‚ñ∂ Ph√°t</button>
        <button class="btn ghost" id="centralNext" title="Ti·∫øp">Ti·∫øp ‚ñ∂</button>
        <button class="btn ghost" id="centralRepeat" title="L·∫∑p l·∫°i">üîÅ L·∫∑p l·∫°i</button>
        <label style="display:flex; align-items:center; gap:8px; font-weight:600; margin-left:8px;"><input type="checkbox" id="centralLoopCheckbox"> T·ª± l·∫∑p l·∫°i</label>
      </div>
    </div>

    <div id="exerciseArea"></div>

    <!-- Role Playing container (hidden until tab selected) -->
    <div id="rolePlayingArea" class="hide" style="margin-top:8px;">
      <div id="app"></div>
    </div>

    <div id="pagination" class="pagination hide">
      <span id="pageInfo" style="font-weight: 600;">1 / 1</span>
      <span id="statusBar" style="font-weight:700; color:var(--muted);">Tr·∫°ng th√°i: Idle</span>
    </div>

    <div id="mainControlPanel" class="control-panel">
      <div class="option-group" style="flex:1">
        <select id="lessonSelect"><option value="">-- Ch·ªçn b√†i h·ªçc --</option></select>
      </div>
      
      <div class="option-group">
        <span>Ngh·ªâ:</span>
        <input type="range" id="delayRange" min="0" max="5000" step="500" value="1000" title="Th·ªùi gian ch·ªù (ms) tr∆∞·ªõc khi chuy·ªÉn c√¢u sau khi ph√°t ƒë√°p √°n ‚Äî k√©o sang tr√°i ƒë·ªÉ nhanh h∆°n">
        <span id="delayVal">1.0s</span>
      </div>

      <div class="option-group">
        <span>ƒê·ªçc ƒë√°p √°n:</span>
        <select id="pauseSelect" style="padding:8px; border-radius:6px;" title="Th·ªùi gian (gi√¢y) ƒë·ªÉ ng∆∞·ªùi h·ªçc nghe/nh·∫Øc l·∫°i sau khi ƒë√°p √°n ƒë∆∞·ª£c ph√°t">
          <option value="0" selected>0s</option>
          <option value="1">1s</option>
          <option value="2">2s</option>
          <option value="3">3s</option>
          <option value="4">4s</option>
          <option value="5">5s</option>
        </select>
        <span id="statusLabel" style="margin-left:12px; font-weight:700; color:var(--text);">Tr·∫°ng th√°i: Idle</span>
      </div>

      <div class="option-group">
        <span>Preview ngh·ªâ:</span>
        <select id="listPauseSelect" style="padding:8px; border-radius:6px;" title="Th·ªùi gian (gi√¢y) gi·ªØa c√°c c√¢u khi nghe Preview">
          <option value="1">1s</option>
          <option value="2" selected>2s</option>
          <option value="3">3s</option>
          <option value="4">4s</option>
          <option value="5">5s</option>
        </select>
      </div>

      <div class="option-group">
        <label style="display:flex; align-items:center; gap:8px; font-weight:600;"><input type="checkbox" id="listLoopCheckbox"> T·ª± l·∫∑p l·∫°i</label>
      </div>

      <div class="option-group">
        <span>Audio Engine:</span>
        <select id="audioEngineSelect" style="padding:8px; border-radius:6px;">
          <option value="gTTS">gTTS (Female US)</option>
          <option value="Edge">Edge TTS (Male US)</option>
        </select>
      </div>

      <div class="option-group">
        <span>T·ª∑ l·ªá ƒë√∫ng:</span>
        <input type="range" id="thresholdRange" min="50" max="95" step="1" value="95" title="ƒêi·ªÅu ch·ªânh nh·∫≠n d·∫°ng ti·∫øng n√≥i (50% - d·ªÖ, 95% - ch√≠nh x√°c t·ªëi ƒëa) T·∫≠p vi·∫øt n√™n ch·ªçn 95%">
        <span id="thresholdVal" style="margin-left:8px; font-weight:700;">95%</span>
        <span title="N·∫øu t·ª∑ l·ªá gi·ªëng (similarity) c·ªßa ph√°t √¢m so v·ªõi ƒë√°p √°n l·ªõn h∆°n ho·∫∑c b·∫±ng gi√° tr·ªã n√†y th√¨ s·∫Ω ƒë∆∞·ª£c ch·∫•m l√† ƒë√∫ng" style="margin-left:8px; color:var(--text);">‚ÑπÔ∏è</span>
      </div>

      <div class="option-group">
        <button class="btn ghost" id="toggleSkillMode" title="B·∫≠t/t·∫Øt ch·∫ø ƒë·ªô luy·ªán n√≥i">üéôÔ∏è Luy·ªán N√≥i</button>
      </div>
      <div class="option-group">
        <span>Phi√™n:</span>
        <input type="number" id="sessionStartInput" min="1" value="1" style="width:70px; padding:6px; border-radius:6px;">
        <span> ƒë·∫øn </span>
        <input type="number" id="sessionEndInput" min="1" value="10" style="width:70px; padding:6px; border-radius:6px;">
        <button class="btn ghost" id="applySessionBtn" title="√Åp d·ª•ng ph·∫°m vi c√¢u cho phi√™n h·ªçc" style="margin-left:8px">√Åp d·ª•ng</button>
        <button class="btn ghost" id="bookmarkBtn" title="Bookmark v·ªã tr√≠ hi·ªán t·∫°i" style="margin-left:8px">üîñ L∆∞u</button>
        <button class="btn ghost" id="loadBookmarkBtn" title="T·∫£i bookmark" style="margin-left:6px">üìÇ T·∫£i</button>
      </div>
    </div>

    <!-- pagination moved above to sit directly under tabs -->
  </div>

  <button id="backToTop" title="L√™n ƒë·∫ßu trang">‚ñ≤</button>

  <script>
    let lessons = [];
    let currentLessonIdx = -1;
    let currentExIdx = 0;
    let isSingleMode = true;
    let isSpeakingMode = false; // d√πng cho luy·ªán n√≥i th·ª±c s·ª±
    // currentMode controls UI: 'sentence' or 'reading'
    let currentMode = 'listeningPreview'; // default to Listening Preview (home)
    let isReadingModeActive = false;
    let delayTimer = null;

    let recognition = null;
    let isRecognitionSupported = false;
    let willRestartRecognition = false;
    let isRecognitionRunning = false;
    let pauseSeconds = 0; // seconds user can read answer (default 0s for immediate resume)
    let matchThreshold = 0.95; // similarity threshold (0..1), default 95% (max)
    // session controls: show only a range of sentences per study session
    let sessionStart = 0; // 0-based index
    let sessionEnd = 9;   // inclusive 0-based index; default show 1..10
    let sessionSize = 10;

    // Listening Preview state
    let listeningPauseSeconds = 2; // pause between sentences in preview (1..5)
    let listeningIndex = 0;
    let isPreviewPlaying = false;
    let previewCanceled = false;
    let listeningAutoLoop = false; // auto-loop session when reaching end
    let readingAutoLoop = false; // auto-loop for Reading Test
    let sentenceAutoLoop = false; // auto-loop for Sentence/Writing Test
    // Dictation mode: automatically play next sentence after correct answer
    let dictationAutoAdvance = true;
    let dictationScheduledPlay = false;

    // Server lesson metadata and audio mapping
    let lessonsMeta = [];
    let audioMapping = [];
    let currentHowl = null;
    let ttsAudio = null; // track TTS Audio object for seeking/rewind
    let rewindSeconds = 3; // seconds to rewind when user requests

    // Load json_list.json to populate server lessons
    function loadLessonList() {
      fetch('json_list.json')
        .then(res => res.json())
        .then(data => {
          lessonsMeta = data.lessons || [];
          // remove previously appended remote options to avoid duplicates
          [...lessonSelect.querySelectorAll('option')].filter(o => o.value && o.value.startsWith('remote:')).forEach(o => o.remove());
          // append server lessons to lessonSelect
          lessonsMeta.forEach((m, i) => {
            const opt = document.createElement('option');
            opt.value = 'remote:' + i;
            opt.textContent = (m.name || '').replace('.json','');
            lessonSelect.appendChild(opt);
          });
        })
        .catch(err => console.log('Kh√¥ng th·ªÉ ƒë·ªçc json_list.json', err));
    }

    // Load a lesson JSON + mapping from LESSON/ folder
    function loadRemoteLesson(idx) {
      const meta = lessonsMeta[idx];
      if (!meta) return;
      fetch('LESSON/' + meta.name)
        .then(r => r.json())
        .then(data => {
          // convert array-of-arrays format into expected lesson object
          const lessonObj = { title: meta.name, fill: [], sentence: [] };
          if (Array.isArray(data)) {
            data.forEach((row, ridx) => {
              // support two array formats:
              // short (6 columns): [term, ipa, vi, example, example_ipa, example_vi]
              // extended (8 columns): [kanji, kana, romaji, vi, example, example_kana, example_romaji, example_vi]
                let front = (row[0] || '').toString().trim();
                let frontIpa = (row[1] || '').toString().trim();
                let frontRomaji = '';
                let frontVi = '';
                let back = '';
                let backIpa = '';
                let backRomaji = '';
                let backVi = '';
                if (row.length >= 8) {
                  front = (row[0] || '').toString().trim();
                  frontIpa = (row[1] || '').toString().trim();
                  frontRomaji = (row[2] || '').toString().trim();
                  frontVi = row[3] || '';
                  back = (row[4] || '').toString().trim();
                  backIpa = (row[5] || '').toString().trim();
                  backRomaji = (row[6] || '').toString().trim();
                  backVi = row[7] || '';
                } else {
                  front = (row[0] || '').toString().trim();
                  frontIpa = (row[1] || '').toString().trim();
                  frontVi = row[2] || '';
                  back = (row[3] || '').toString().trim();
                  backIpa = (row[4] || '').toString().trim();
                  backVi = row[5] || '';
                }
                lessonObj.fill.push({ id: ridx, question: front, answer: front, hint_vi: frontVi, ipa: frontIpa, romaji: frontRomaji });
                // If both front (question) and back (answer) exist and differ, create two practice items:
                // 1) practice the question line (user reads the question)
                // 2) practice the answer line (user reads the answer)
                if (front && back && front !== back) {
                  lessonObj.sentence.push({ id: ridx*2, prompt: front, answer: front, prompt_vi: frontVi, ipa: frontIpa, romaji: frontRomaji });
                  lessonObj.sentence.push({ id: ridx*2 + 1, prompt: back, answer: back, prompt_vi: backVi, ipa: backIpa, romaji: backRomaji });
                } else {
                  // single-sentence format: use whichever text is present
                  const text = back || front || '';
                  const ipaText = back ? backIpa : frontIpa;
                  const romajiText = back ? backRomaji : frontRomaji;
                  lessonObj.sentence.push({ id: ridx, prompt: text, answer: text, prompt_vi: backVi || frontVi, ipa: ipaText, romaji: romajiText });
                }
            });
          } else {
            // if lesson is already in object format, try to use its fill/sentence
            lessonObj.fill = data.fill || data.items || [];
            lessonObj.sentence = data.sentence || [];
          }

          // load mapping
          if (meta.mapping) {
            fetch('LESSON/' + meta.mapping)
              .then(r => r.json())
              .then(map => {
                audioMapping = map || [];
              })
              .catch(e => { console.log('Kh√¥ng ƒë·ªçc ƒë∆∞·ª£c mapping:', e); audioMapping = []; });
          } else {
            audioMapping = [];
          }

          // replace lessons with this remote lesson for convenience
          lessons = [lessonObj];
          currentLessonIdx = 0;
          currentExIdx = 0;
          // Default session: entire lesson
          const totalItems = (lessonObj.sentence || []).length || 0;
          sessionStart = 0;
          sessionEnd = Math.max(0, totalItems - 1);
          sessionSize = Math.max(1, sessionEnd - sessionStart + 1);
          try {
            document.getElementById('sessionStartInput').value = totalItems > 0 ? 1 : 0;
            document.getElementById('sessionEndInput').value = totalItems > 0 ? (sessionEnd + 1) : 0;
          } catch (e) { /* ignore if UI not ready */ }
          render();
          // If RolePlay app exists, sync it to the newly loaded lesson so user doesn't need to switch tabs
          try {
            if (window.rolePlayInstance && typeof window.rolePlayInstance.setState === 'function') {
              // set RolePlay selected index to the same remote index so it points to the same lesson
              window.rolePlayInstance.setState({ currentLesson: lessonObj, selectedLessonIndex: idx });
              if (typeof window.rolePlayInstance.loadSelectedLesson === 'function') window.rolePlayInstance.loadSelectedLesson();
            }
          } catch (e) { console.warn('Failed to sync RolePlay after loadRemoteLesson', e); }
        })
        .catch(err => console.error('L·ªói khi t·∫£i b√†i h·ªçc:', err));
    }

    const lessonSelect = document.getElementById('lessonSelect');
    const exerciseArea = document.getElementById('exerciseArea');
    const delayRange = document.getElementById('delayRange');
    const skillBtn = document.getElementById('toggleSkillMode');

    delayRange.addEventListener('input', (e) => {
      document.getElementById('delayVal').textContent = (e.target.value / 1000).toFixed(1) + 's';
    });

    // thresholdRange controls fuzzy matching tolerance for correctness (50% - 100%)
    document.getElementById('thresholdRange').addEventListener('input', (e) => {
      const val = parseInt(e.target.value, 10) || 100;
      document.getElementById('thresholdVal').textContent = val + '%';
      matchThreshold = val / 100;
    });

    // pauseSelect controls how long to show answer after playback (1-5s)
    document.getElementById('pauseSelect').addEventListener('change', (e) => {
      pauseSeconds = parseInt(e.target.value, 10) || 2;
    });

    // Listening Preview pause select
    const listPauseSelect = document.getElementById('listPauseSelect');
    if (listPauseSelect) {
      listPauseSelect.addEventListener('change', (e) => {
        listeningPauseSeconds = parseInt(e.target.value, 10) || 2;
      });
    }

    // Listening Preview auto-loop checkbox
    const listLoopCheckbox = document.getElementById('listLoopCheckbox');
    if (listLoopCheckbox) {
      listLoopCheckbox.addEventListener('change', (e) => { listeningAutoLoop = !!e.target.checked; });
    }

    // keep global auto-loop checkbox as master: when changed, update other modes' loop flags and visible checkboxes
    if (listLoopCheckbox) {
      listLoopCheckbox.addEventListener('change', (e) => {
        const checked = !!e.target.checked;
        listeningAutoLoop = checked;
        readingAutoLoop = checked;
        sentenceAutoLoop = checked;
        // update visible controls if present
        const rcb = document.getElementById('readingLoopCheckbox'); if (rcb) rcb.checked = checked;
        const sb = document.getElementById('sentenceLoopCheckbox'); if (sb) sb.checked = checked;
        const lp = document.getElementById('lpAutoLoop'); if (lp) lp.checked = checked;
      });
    }

    // session apply / bookmark handlers
    document.getElementById('applySessionBtn').addEventListener('click', () => {
      const lesson = lessons[currentLessonIdx] || {};
      const total = (lesson.sentence || []).length || 0;
      let s = parseInt(document.getElementById('sessionStartInput').value, 10) || 1;
      let e = parseInt(document.getElementById('sessionEndInput').value, 10) || Math.min(s + sessionSize - 1, total);
      s = Math.max(1, Math.min(s, total));
      e = Math.max(s, Math.min(e, total));
      sessionStart = s - 1;
      sessionEnd = e - 1;
      sessionSize = sessionEnd - sessionStart + 1;
      currentExIdx = sessionStart;
      setStatus(`Phi√™n: ${s} - ${e}`, 'var(--muted)');
      if (currentMode === 'reading') renderReading(); else render();
    });

    document.getElementById('bookmarkBtn').addEventListener('click', () => {
      if (currentLessonIdx === -1) return setStatus('Kh√¥ng c√≥ b√†i ƒë·ªÉ bookmark', 'var(--error)');
      const lesson = lessons[currentLessonIdx];
      const key = `bookmark_${lesson.title || 'lesson'}`;
      const payload = {
        sessionStart: sessionStart,
        sessionEnd: sessionEnd,
        sessionSize: sessionSize,
        current: currentExIdx,
        threshold: Math.round(matchThreshold * 100),
        listeningAutoLoop: !!listeningAutoLoop,
        readingAutoLoop: !!readingAutoLoop,
        sentenceAutoLoop: !!sentenceAutoLoop,
        isSingleMode: !!isSingleMode,
        currentMode: currentMode || 'reading'
      };
      try {
        localStorage.setItem(key, JSON.stringify(payload));
        // also save a fallback last_bookmark for cross-page recovery
        try { localStorage.setItem('last_bookmark', JSON.stringify({ key, payload, page: window.location.pathname, ts: Date.now() })); } catch (e) { /* ignore */ }
        setStatus('ƒê√£ l∆∞u bookmark', 'green');
        console.log('Saved bookmark', key, payload);
      } catch (e) { setStatus('L∆∞u bookmark th·∫•t b·∫°i', 'var(--error)'); console.error('bookmark save error', e); }
    });

    document.getElementById('loadBookmarkBtn').addEventListener('click', () => {
      if (currentLessonIdx === -1) return setStatus('Kh√¥ng c√≥ b√†i ƒë·ªÉ t·∫£i bookmark', 'var(--error)');
      const lesson = lessons[currentLessonIdx];
      const key = `bookmark_${lesson.title || 'lesson'}`;
      try {
        let raw = localStorage.getItem(key);
        // fallback to last_bookmark if specific key not found
        if (!raw) {
          const last = localStorage.getItem('last_bookmark');
          if (last) {
            try {
              const parsedLast = JSON.parse(last);
              // if last_bookmark contains the same lesson key, use it; otherwise still allow user to restore
              raw = parsedLast && parsedLast.payload ? JSON.stringify(parsedLast.payload) : null;
              console.warn('Using fallback last_bookmark for restore');
            } catch (e) { /* ignore parse error */ }
          }
        }
        if (!raw) return setStatus('Kh√¥ng t√¨m th·∫•y bookmark', 'var(--muted)');
        const obj = JSON.parse(raw);
        sessionStart = (typeof obj.sessionStart === 'number') ? obj.sessionStart : 0;
        // restore sessionEnd and sessionSize if provided
        if (typeof obj.sessionEnd === 'number') {
          sessionEnd = Math.min(obj.sessionEnd, (lesson.sentence || []).length - 1);
        } else {
          sessionEnd = Math.min(sessionStart + sessionSize - 1, (lesson.sentence || []).length - 1);
        }
        sessionSize = (typeof obj.sessionSize === 'number') ? Math.max(1, Math.min(obj.sessionSize, (lesson.sentence || []).length)) : (sessionEnd - sessionStart + 1);
        currentExIdx = (typeof obj.current === 'number') ? obj.current : sessionStart;
        // update inputs (1-based)
        document.getElementById('sessionStartInput').value = sessionStart + 1;
        document.getElementById('sessionEndInput').value = sessionEnd + 1;
        // restore threshold if present
        if (typeof obj.threshold === 'number') {
          const perc = Math.max(50, Math.min(100, obj.threshold));
          document.getElementById('thresholdRange').value = perc;
          document.getElementById('thresholdVal').textContent = perc + '%';
          matchThreshold = perc / 100;
        }
        // restore auto-loop flags and UI state
        if (typeof obj.listeningAutoLoop === 'boolean') {
          listeningAutoLoop = obj.listeningAutoLoop;
          const globalAuto = document.getElementById('listLoopCheckbox'); if (globalAuto) globalAuto.checked = !!listeningAutoLoop;
        }
        if (typeof obj.readingAutoLoop === 'boolean') {
          readingAutoLoop = obj.readingAutoLoop;
          const readingCb = document.getElementById('readingLoopCheckbox'); if (readingCb) readingCb.checked = !!readingAutoLoop;
        }
        if (typeof obj.sentenceAutoLoop === 'boolean') {
          sentenceAutoLoop = obj.sentenceAutoLoop;
          const sentenceCb = document.getElementById('sentenceLoopCheckbox'); if (sentenceCb) sentenceCb.checked = !!sentenceAutoLoop;
        }
        if (typeof obj.isSingleMode === 'boolean') {
          isSingleMode = obj.isSingleMode;
          const viewBtn = document.getElementById('toggleViewMode'); if (viewBtn) {
            viewBtn.textContent = isSingleMode ? 'Ch·∫ø ƒë·ªô: C√¢u ƒë∆°n' : 'Ch·∫ø ƒë·ªô: T·∫•t c·∫£';
            viewBtn.classList.toggle('active-mode', !!isSingleMode);
          }
        }
        if (obj.currentMode) {
          currentMode = obj.currentMode;
          // update tab classes
          const tRead = document.getElementById('tabReading'); const tListen = document.getElementById('tabListeningPreview'); const tSent = document.getElementById('tabSentence');
          if (tRead) tRead.classList.toggle('active', currentMode === 'reading');
          if (tListen) tListen.classList.toggle('active', currentMode === 'listeningPreview');
          if (tSent) tSent.classList.toggle('active', currentMode === 'sentence');
        }
        setStatus('ƒê√£ t·∫£i bookmark', 'green');
        console.log('Loaded bookmark', key, obj);
        if (currentMode === 'reading') renderReading(); else render();
      } catch (e) { setStatus('T·∫£i bookmark l·ªói', 'var(--error)'); console.error('bookmark load error', e); }
    });

    function setStatus(text, color) {
      const label = document.getElementById('statusLabel');
      if (label) {
        label.textContent = 'Tr·∫°ng th√°i: ' + text;
        label.style.color = color || 'var(--muted)';
      }
      const sb = document.getElementById('statusBar');
      if (sb) {
        sb.textContent = 'Tr·∫°ng th√°i: ' + text;
        sb.style.color = color || 'var(--muted)';
      }
      const rsb = document.getElementById('readingStatusBar');
      if (rsb) {
        rsb.textContent = 'Tr·∫°ng th√°i: ' + text;
        rsb.style.color = color || 'var(--muted)';
      }
    }

    function initSpeechRecognition() {
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition) {
        alert("Tr√¨nh duy·ªát n√†y kh√¥ng h·ªó tr·ª£ luy·ªán n√≥i (Speech Recognition). Vui l√≤ng d√πng Google Chrome.");
        isRecognitionSupported = false;
        return;
      }
      isRecognitionSupported = true;
      recognition = new SpeechRecognition();
      recognition.lang = "en-US";
      recognition.continuous = false;
      recognition.interimResults = false;

      recognition.onresult = (event) => {
        const text = event.results[0][0].transcript;
        if (currentMode === 'reading' && isReadingModeActive) {
          handleReadingResult(text);
        } else {
          handleSpeechResult(text);
        }
      };

      recognition.onstart = () => { isRecognitionRunning = true; };
      recognition.onend = () => {
        isRecognitionRunning = false;
        if (isSpeakingMode || isReadingModeActive) {
          // n·∫øu ƒëang t·∫°m d·ª´ng v√¨ playback th√¨ kh√¥ng restart ·ªü ƒë√¢y
          if (willRestartRecognition) return;
          try {
            if (!isRecognitionRunning) recognition.start();
          } catch (e) {
            console.log("Cannot restart recognition immediately:", e);
          }
        }
      };

      recognition.onerror = (event) => {
        console.log("Speech recognition error:", event.error);
      };
    }

    function cleanSpeech(str) {
      return str
        .toLowerCase()
        .replace(/\./g, "")              // b·ªè d·∫•u ch·∫•m
        .replace(/:/g, "")               // b·ªè d·∫•u :
        .replace(/a\s*m/g, "am")         // chu·∫©n h√≥a am
        .replace(/p\s*m/g, "pm")         // chu·∫©n h√≥a pm
        .replace(/(\d+)00/g, "$1")       // 7:00 ‚Üí 7
        .replace(/everyday/g, "every day") // s·ª≠a everyday ‚Üí every day
        .replace(/[^\w\s]/g, "")         // b·ªè k√Ω t·ª± ƒë·∫∑c bi·ªát
        .replace(/\s+/g, " ")            // chu·∫©n h√≥a kho·∫£ng tr·∫Øng
        .trim();
    }

    // Levenshtein distance for fuzzy matching
    function levenshtein(a, b) {
      const an = a ? a.length : 0;
      const bn = b ? b.length : 0;
      if (an === 0) return bn;
      if (bn === 0) return an;
      const matrix = Array.from({ length: bn + 1 }, (_, i) => new Array(an + 1));
      for (let i = 0; i <= bn; i++) matrix[i][0] = i;
      for (let j = 0; j <= an; j++) matrix[0][j] = j;
      for (let i = 1; i <= bn; i++) {
        for (let j = 1; j <= an; j++) {
          const cost = a[j - 1] === b[i - 1] ? 0 : 1;
          matrix[i][j] = Math.min(
            matrix[i - 1][j] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j - 1] + cost
          );
        }
      }
      return matrix[bn][an];
    }

    function similarity(a, b) {
      const s1 = cleanSpeech((a || '').toString());
      const s2 = cleanSpeech((b || '').toString());
      if (!s1 && !s2) return 1;
      const dist = levenshtein(s1, s2);
      const max = Math.max(s1.length, s2.length);
      return max === 0 ? 1 : Math.max(0, 1 - dist / max);
    }

    function startSpeechMode() {
      if (!recognition) {
        initSpeechRecognition();
      }
      if (!isRecognitionSupported) return;
      isSpeakingMode = true;
      // √©p v·ªÅ ch·∫ø ƒë·ªô c√¢u ƒë∆°n ƒë·ªÉ luy·ªán n√≥i theo t·ª´ng c√¢u
      if (!isSingleMode) {
        isSingleMode = true;
        const viewBtn = document.getElementById('toggleViewMode');
        viewBtn.textContent = 'Ch·∫ø ƒë·ªô: C√¢u ƒë∆°n';
        viewBtn.classList.add('active-mode');
      }
      currentExIdx = 0;
      render();
      try {
        // For Dictation mode we want to play the sentence first and then start recognition
        // so defer auto-start of the recognizer to the renderer which handles playback coordination.
        if (currentMode !== 'dictation') {
          if (!isRecognitionRunning) recognition.start();
        }
      } catch (e) {
        console.log("Recognition already started:", e);
      }
    }

    function stopSpeechMode() {
      isSpeakingMode = false;
      if (recognition) {
        try {
          recognition.stop();
        } catch (e) {
          console.log("Error stopping recognition:", e);
        }
      }
      render();
    }

    function handleSpeechResult(text) {
      if (currentLessonIdx === -1) return;
      const lesson = lessons[currentLessonIdx];
      const data = lesson.sentence || [];
      const item = data[currentExIdx];
      if (!item) return;

      const answer = item.answer_en || item.answer || item.prompt || '';
      // Try to find feedback element used by different modes (sentence vs dictation)
      const fb = document.getElementById(`fb_${currentExIdx}`) || document.getElementById(`fb_dict_${currentExIdx}`) || document.getElementById('fb_reading');
      // if no fb element exists, still continue silently

      const clean = (str) => str.toLowerCase()
        .replace(/[.,\/#!$%\^&\*;:{}=\-_`~()?"']/g,"")
        .replace(/\s{2,}/g," ")
        .trim();

      if (similarity(text, answer) >= matchThreshold) {
        const viTrans = item.prompt_vi || "";
        if (fb) {
          fb.className = 'feedback success';
          fb.innerHTML = `‚úÖ Ch√≠nh x√°c!${viTrans ? `<br><span class="translation-hint"> Nghƒ©a: ${viTrans}</span>` : ''}`;
        }

        playAudioFor(answer);

        clearTimeout(delayTimer);
        delayTimer = setTimeout(() => {
          // Advance similarly to Dictation Enter behaviour when in dictation mode
          if (currentMode === 'dictation') {
            if (currentExIdx < sessionEnd) {
              currentExIdx++;
              if (dictationAutoAdvance) dictationScheduledPlay = true;
              renderDictation();
            } else {
              if (sentenceAutoLoop) {
                currentExIdx = sessionStart;
                if (dictationAutoAdvance) dictationScheduledPlay = true;
                renderDictation();
              } else setStatus('Ho√†n th√†nh phi√™n', 'var(--muted)');
            }
          } else {
            // default behaviour for sentence mode
            if (currentExIdx < data.length - 1) {
              currentExIdx++;
              render();
            }
          }
        }, parseInt(delayRange.value));
      } else {
        if (fb) {
          fb.className = 'feedback error';
          fb.innerHTML = `‚ùå B·∫°n n√≥i: "<span>${text}</span>"<br>ƒê√°p √°n ƒë√∫ng: ${answer}`;
        }
        // play correct answer for user to repeat
        playAudioFor(answer);
      }
    }

    function handleReadingResult(text) {
      if (currentLessonIdx === -1) return;
      const lesson = lessons[currentLessonIdx];
      const data = lesson.sentence || [];
      const item = data[currentExIdx];
      if (!item) return;

      const expected = item.answer || item.prompt || '';
      const fb = document.getElementById('fb_reading');
      if (!fb) return;

      if (similarity(text, expected) >= matchThreshold) {
        fb.className = 'feedback success';
        fb.innerHTML = `‚úÖ Ch√≠nh x√°c!`;
        // play back correct answer then move to next
        playAudioFor(expected, () => {
          // advance to next sentence (respect sessionEnd)
            if (currentExIdx < sessionEnd) {
              currentExIdx = Math.min(sessionEnd, currentExIdx + 1);
              renderReading();
            } else {
            // finished
            if (readingAutoLoop) {
              // restart session
              currentExIdx = sessionStart;
              setStatus('T·ª± l·∫∑p l·∫°i (Looping)...', 'var(--accent)');
              // keep reading mode active and restart recognition
              if (!recognition) initSpeechRecognition();
              try { if (!isRecognitionRunning && recognition) recognition.start(); } catch(e) { console.log('start recognition failed', e); }
              renderReading();
            } else {
              isReadingModeActive = false;
              setStatus('Ho√†n th√†nh', 'var(--success)');
              renderReading();
            }
          }
        });
      } else {
        fb.className = 'feedback error';
        fb.innerHTML = `‚ùå B·∫°n n√≥i: "<span>${text}</span>"`;
        // play correct answer for user to repeat
        playAudioFor(expected);
      }
    }

    skillBtn.addEventListener('click', () => {
      if (!isSpeakingMode) {
        skillBtn.textContent = 'üõë D·ª´ng Luy·ªán N√≥i';
        skillBtn.classList.add('speaking-on');
        startSpeechMode();
      } else {
        skillBtn.textContent = 'üéôÔ∏è Luy·ªán N√≥i';
        skillBtn.classList.remove('speaking-on');
        stopSpeechMode();
      }
    });

    const themeToggleBtn = document.getElementById('themeToggle');
    if (themeToggleBtn) {
      // initialize icon based on current theme
      const initIsLight = document.body.getAttribute('data-theme') === 'light';
      themeToggleBtn.textContent = initIsLight ? '‚òÄÔ∏è' : 'üåô';
      themeToggleBtn.addEventListener('click', () => {
        const isLight = document.body.getAttribute('data-theme') === 'light';
        const newTheme = isLight ? 'dark' : 'light';
        document.body.setAttribute('data-theme', newTheme);
        themeToggleBtn.textContent = newTheme === 'light' ? '‚òÄÔ∏è' : 'üåô';
      });
    }

    window.addEventListener('scroll', () => {
      document.getElementById('backToTop').classList.toggle('show', window.scrollY > 200);
    });
    document.getElementById('backToTop').addEventListener('click', () => window.scrollTo({top: 0}));

    // load server lessons list on startup
    loadLessonList();

    // initialize audio engine selector from localStorage
    const engineSel = document.getElementById('audioEngineSelect');
    if (engineSel) {
      const saved = localStorage.getItem('preferred_tts_engine');
      if (saved) engineSel.value = saved;
      engineSel.addEventListener('change', (e) => { localStorage.setItem('preferred_tts_engine', e.target.value); });
    }

    // Tab handlers for switching modes
    document.getElementById('tabSentence').addEventListener('click', () => {
      currentMode = 'sentence';
      document.getElementById('tabSentence').classList.add('active');
      document.getElementById('tabReading').classList.remove('active');
      const tDict = document.getElementById('tabDictation'); if (tDict) tDict.classList.remove('active');
      isReadingModeActive = false;
      // show main controls, hide RolePlay area
      const mainCtrl = document.getElementById('mainControlPanel'); if (mainCtrl) mainCtrl.classList.remove('hide');
      const rp = document.getElementById('rolePlayingArea'); if (rp) rp.classList.add('hide');
      const ex = document.getElementById('exerciseArea'); if (ex) ex.classList.remove('hide');
      const pg = document.getElementById('pagination'); if (pg) pg.classList.remove('hide');
      const tRole = document.getElementById('tabRolePlaying'); if (tRole) tRole.classList.remove('active');
      // stop RolePlay app if active to avoid microphone conflicts
      try { if (window.rolePlayInstance && typeof window.rolePlayInstance.stopPractice === 'function') window.rolePlayInstance.stopPractice();
      else if (window.rolePlayInstance && window.rolePlayInstance.speechRecognition) try { window.rolePlayInstance.speechRecognition.stop(); } catch(e) {} } catch(e) {}
      render();
    });

    document.getElementById('tabReading').addEventListener('click', () => {
      currentMode = 'reading';
      document.getElementById('tabReading').classList.add('active');
      document.getElementById('tabSentence').classList.remove('active');
      const tDict = document.getElementById('tabDictation'); if (tDict) tDict.classList.remove('active');
      // show main controls, hide RolePlay area
      const mainCtrl = document.getElementById('mainControlPanel'); if (mainCtrl) mainCtrl.classList.remove('hide');
      const rp = document.getElementById('rolePlayingArea'); if (rp) rp.classList.add('hide');
      const ex = document.getElementById('exerciseArea'); if (ex) ex.classList.remove('hide');
      const pg = document.getElementById('pagination'); if (pg) pg.classList.remove('hide');
      const tRole = document.getElementById('tabRolePlaying'); if (tRole) tRole.classList.remove('active');
      // stop RolePlay app if active to avoid microphone conflicts
      try { if (window.rolePlayInstance && typeof window.rolePlayInstance.stopPractice === 'function') window.rolePlayInstance.stopPractice();
      else if (window.rolePlayInstance && window.rolePlayInstance.speechRecognition) try { window.rolePlayInstance.speechRecognition.stop(); } catch(e) {} } catch(e) {}
      renderReading();
    });

    // Listening Preview tab
    const tabListeningPreview = document.getElementById('tabListeningPreview');
    if (tabListeningPreview) {
      tabListeningPreview.addEventListener('click', () => {
        currentMode = 'listeningPreview';
        // set active states
        tabListeningPreview.classList.add('active');
        document.getElementById('tabReading').classList.remove('active');
        document.getElementById('tabSentence').classList.remove('active');
          const tDict = document.getElementById('tabDictation'); if (tDict) tDict.classList.remove('active');
        // show main controls, hide RolePlay area
        const mainCtrl = document.getElementById('mainControlPanel'); if (mainCtrl) mainCtrl.classList.remove('hide');
        const rp = document.getElementById('rolePlayingArea'); if (rp) rp.classList.add('hide');
        const ex = document.getElementById('exerciseArea'); if (ex) ex.classList.remove('hide');
        const pg = document.getElementById('pagination'); if (pg) pg.classList.add('hide');
        const tRole = document.getElementById('tabRolePlaying'); if (tRole) tRole.classList.remove('active');
        // stop RolePlay app if active to avoid dual mic usage
        try { if (window.rolePlayInstance && typeof window.rolePlayInstance.stopPractice === 'function') window.rolePlayInstance.stopPractice();
        else if (window.rolePlayInstance && window.rolePlayInstance.speechRecognition) try { window.rolePlayInstance.speechRecognition.stop(); } catch(e) {} } catch(e) {}
        renderListeningPreview();
      });
    }

    // Role Playing tab
    const tabRole = document.getElementById('tabRolePlaying');
    if (tabRole) {
      tabRole.addEventListener('click', () => {
        currentMode = 'roleplaying';
        tabRole.classList.add('active');
        const tListen = document.getElementById('tabListeningPreview'); if (tListen) tListen.classList.remove('active');
        const tRead = document.getElementById('tabReading'); if (tRead) tRead.classList.remove('active');
        const tSent = document.getElementById('tabSentence'); if (tSent) tSent.classList.remove('active');
        const tDict = document.getElementById('tabDictation'); if (tDict) tDict.classList.remove('active');
        // hide main exercise area and pagination
        const ex = document.getElementById('exerciseArea'); if (ex) ex.classList.add('hide');
        const pg = document.getElementById('pagination'); if (pg) pg.classList.add('hide');
        // hide main control panel to avoid duplicate controls when Role Playing app shows its own panel
        const mainCtrl = document.getElementById('mainControlPanel'); if (mainCtrl) mainCtrl.classList.add('hide');
        // show role playing area
        const rp = document.getElementById('rolePlayingArea'); if (rp) rp.classList.remove('hide');
        // stop main recognition to avoid mic conflicts, then ensure RolePlay app is initialized
        try { if (recognition && isRecognitionRunning) { try { recognition.stop(); } catch(e) { console.warn('stop main recognition failed', e); } } } catch(e) {}
        // ensure the embedded RolePlay app is initialized and synced with main lessonSelect
        try {
          if (window.rolePlayInstance && typeof window.rolePlayInstance.render === 'function') {
            // stop any running RolePlay state before re-render to avoid duplicate listeners
            try { if (window.rolePlayInstance && typeof window.rolePlayInstance.stopPractice === 'function') window.rolePlayInstance.stopPractice(); } catch(e) {}
            window.rolePlayInstance.render();
            const v = (lessonSelect && lessonSelect.value) ? lessonSelect.value : '';
            if (v) {
              if (v.startsWith('remote:')) {
                const idx = parseInt(v.split(':')[1], 10);
                if (!isNaN(idx)) {
                  window.rolePlayInstance.setState({ selectedLessonIndex: idx });
                  window.rolePlayInstance.loadSelectedLesson();
                }
              } else if (!isNaN(parseInt(v))) {
                const idx = parseInt(v, 10);
                window.rolePlayInstance.setState({ selectedLessonIndex: idx });
                window.rolePlayInstance.loadSelectedLesson();
              }
            } else if (typeof currentLessonIdx !== 'undefined' && currentLessonIdx !== -1) {
              // fallback: if main app already has a loaded lesson, use it for RolePlay
              try {
                window.rolePlayInstance.setState({ selectedLessonIndex: currentLessonIdx });
                window.rolePlayInstance.loadSelectedLesson();
              } catch (e) { console.warn('RolePlay loadSelectedLesson fallback failed', e); }
            }
          }
        } catch (e) { console.warn('RolePlay sync failed', e); }
      });
    }

    lessonSelect.addEventListener('change', (e) => { 
      const v = e.target.value;
      if (!v) return;
      if (v.startsWith('remote:')) {
        const idx = parseInt(v.split(':')[1], 10);
        loadRemoteLesson(idx);
        return;
      }
      // local imported lessons (legacy behaviour)
      if (!isNaN(parseInt(v))) {
        currentLessonIdx = parseInt(v);
        currentExIdx = 0;
        // Default session to whole lesson when switching to a local lesson
        try {
          const lesson = lessons[currentLessonIdx] || {};
          const total = (lesson.sentence || []).length || 0;
          sessionStart = 0;
          sessionEnd = Math.max(0, total - 1);
          sessionSize = Math.max(1, sessionEnd - sessionStart + 1);
          document.getElementById('sessionStartInput').value = total > 0 ? 1 : 0;
          document.getElementById('sessionEndInput').value = total > 0 ? (sessionEnd + 1) : 0;
        } catch (e) { /* ignore UI errors */ }
        render();
        // sync RolePlay instance to the selected lesson so RolePlay doesn't require switching tabs
        try {
          if (window.rolePlayInstance && typeof window.rolePlayInstance.setState === 'function') {
            window.rolePlayInstance.setState({ selectedLessonIndex: currentLessonIdx, currentLesson: lessons[currentLessonIdx] || null });
            if (typeof window.rolePlayInstance.loadSelectedLesson === 'function') window.rolePlayInstance.loadSelectedLesson();
          }
        } catch (e) { console.warn('Failed to sync RolePlay after lessonSelect change', e); }
      }
    });
    
    // tabs removed: only Sentence writing supported

    function render() {
      // dispatch to specific renderers based on currentMode
      if (currentMode === 'reading') {
        renderReading();
        return;
      }
      if (currentMode === 'listeningPreview') {
        renderListeningPreview();
        return;
      }
      if (currentMode === 'dictation') {
        renderDictation();
        return;
      }
      exerciseArea.innerHTML = '';
      if (currentLessonIdx === -1) {
        exerciseArea.innerHTML = '<div style="text-align:center; padding: 50px; color: var(--muted);">Vui l√≤ng ch·ªçn b√†i h·ªçc ƒë·ªÉ b·∫Øt ƒë·∫ßu.</div>';
        document.getElementById('pagination').classList.add('hide');
        return;
      }
      const lesson = lessons[currentLessonIdx];
      const data = lesson.sentence || [];
      const total = data.length;
      // clamp session range
      sessionStart = Math.max(0, Math.min(sessionStart, Math.max(0, total - 1)));
      sessionEnd = Math.max(sessionStart, Math.min(sessionEnd, total - 1));

      // If in sentence/writing mode, show session controls (Restart + Auto-loop)
      // Sentence mode: per-mode control panel removed ‚Äî use central control bar for navigation and play.

      if (isSingleMode) {
        document.getElementById('pagination').classList.remove('hide');
        renderItem(data[currentExIdx], currentExIdx, total);
        const visibleCount = sessionEnd - sessionStart + 1;
        document.getElementById('pageInfo').textContent = `${currentExIdx - sessionStart + 1} / ${visibleCount} (t·ªïng ${total})`;
      } else {
        document.getElementById('pagination').classList.add('hide');
        // render only items in the session range
        for (let i = sessionStart; i <= sessionEnd; i++) {
          renderItem(data[i], i, total);
        }
      }
      
      const firstInput = exerciseArea.querySelector('input[type="text"], textarea, input[id^="input_"]');
      if (firstInput) {
        if (isSpeakingMode) {
          firstInput.placeholder = 'üé§ ƒêang nghe... h√£y n√≥i';
        } else {
          firstInput.placeholder = 'Nh·∫≠p c√¢u tr·∫£ l·ªùi...';
        }
        // delay focusing slightly to avoid being overridden by audio/recognition handlers
        setTimeout(() => {
          try { firstInput.focus(); if (typeof firstInput.select === 'function') firstInput.select(); } catch (e) { /* ignore */ }
        }, 50);
      }
    }

    // Dictation tab
    const tabDict = document.getElementById('tabDictation');
    if (tabDict) {
      tabDict.addEventListener('click', () => {
        currentMode = 'dictation';
        tabDict.classList.add('active');
        const tListen = document.getElementById('tabListeningPreview'); if (tListen) tListen.classList.remove('active');
        const tRead = document.getElementById('tabReading'); if (tRead) tRead.classList.remove('active');
        const tSent = document.getElementById('tabSentence'); if (tSent) tSent.classList.remove('active');
        const tRole = document.getElementById('tabRolePlaying'); if (tRole) tRole.classList.remove('active');
        const mainCtrl = document.getElementById('mainControlPanel'); if (mainCtrl) mainCtrl.classList.remove('hide');
        const rp = document.getElementById('rolePlayingArea'); if (rp) rp.classList.add('hide');
        const ex = document.getElementById('exerciseArea'); if (ex) ex.classList.remove('hide');
        const pg = document.getElementById('pagination'); if (pg) pg.classList.remove('hide');
        renderDictation();
      });
    }

    function renderReading() {
      exerciseArea.innerHTML = '';
      if (currentLessonIdx === -1) {
        exerciseArea.innerHTML = '<div style="text-align:center; padding: 50px; color: var(--muted);">Vui l√≤ng Import ho·∫∑c ch·ªçn b√†i h·ªçc ƒë·ªÉ b·∫Øt ƒë·∫ßu Reading Test.</div>';
        document.getElementById('pagination').classList.add('hide');
        return;
      }
      const lesson = lessons[currentLessonIdx];
      const data = lesson.sentence || [];
      const total = data.length;
      // clamp session range
      sessionStart = Math.max(0, Math.min(sessionStart, Math.max(0, total - 1)));
      sessionEnd = Math.max(sessionStart, Math.min(sessionEnd, total - 1));
      // ensure currentExIdx is within session
      currentExIdx = Math.max(sessionStart, Math.min(currentExIdx, sessionEnd));
      if (data.length === 0) {
        exerciseArea.innerHTML = '<div style="text-align:center; padding: 50px; color: var(--muted);">Kh√¥ng c√≥ c√¢u ƒë·ªÉ luy·ªán ƒë·ªçc trong b√†i h·ªçc n√†y.</div>';
        return;
      }
      document.getElementById('pagination').classList.add('hide');
      const item = data[currentExIdx];
      const card = document.createElement('div');
      card.className = 'exercise-item';
      card.innerHTML = `
        <div id="reading_eng" style="font-size:1.6rem; font-weight:700; text-align:center; margin-bottom:6px; line-height:1.05; color:#2563EB;">${currentExIdx+1}. ${item.prompt || item.answer}</div>
        <div id="reading_ipa" style="font-size:0.98rem; font-style:italic; color:#C586C0; margin-bottom:6px; text-align:center; line-height:1.05">${item.ipa || ''}</div>
        <div id="reading_romaji" style="font-size:0.98rem; color:#C586C0; margin-bottom:6px; text-align:center; line-height:1.05">${item.romaji || ''}</div>
        <div id="reading_vn" style="font-size:0.98rem; color:#12C07A; margin-bottom:6px; text-align:center; line-height:1.05">${item.prompt_vi || ''}</div>
        <div class="feedback" id="fb_reading" style="margin-top:4px;"></div>
      `;
      exerciseArea.appendChild(card);

      // Make Reading Test card match Listening Preview: use min-height so it can grow with zoom
      card.style.display = 'flex';
      card.style.flexDirection = 'column';
      card.style.alignItems = 'center';
      card.style.justifyContent = 'center';
      card.style.textAlign = 'center';
      card.style.minHeight = '120px';
      card.style.padding = '12px';

      // Hide global pagination for Reading (we display progress under the card)
      const pg = document.getElementById('pagination'); if (pg) pg.classList.add('hide');
      // create a separate progress + status row below the card (outside the exercise-item)
      let rpInfo = document.getElementById('readingPageInfo');
      if (!rpInfo) {
        const rpRow = document.createElement('div');
        rpRow.id = 'readingProgressRow';
        rpRow.style.cssText = 'display:flex; gap:12px; justify-content:center; align-items:center; margin-top:12px; margin-bottom:40px; font-weight:700;';
        rpInfo = document.createElement('span');
        rpInfo.id = 'readingPageInfo';
        rpInfo.style.fontWeight = '700';
        const rStatus = document.createElement('span');
        rStatus.id = 'readingStatusBar';
        rStatus.style.fontWeight = '700';
        rStatus.style.color = 'var(--muted)';
        rpRow.appendChild(rpInfo);
        rpRow.appendChild(rStatus);
        exerciseArea.appendChild(rpRow);
      }
      const visibleCount = sessionEnd - sessionStart + 1;
      rpInfo.textContent = `${currentExIdx - sessionStart + 1} / ${visibleCount} (t·ªïng ${total})`;
    }

    // Listening Preview renderer ‚Äî single live card only
    function renderListeningPreview() {
      exerciseArea.innerHTML = '';
      if (currentLessonIdx === -1) {
        exerciseArea.innerHTML = '<div style="text-align:center; padding: 50px; color: var(--muted);">Vui l√≤ng ch·ªçn b√†i h·ªçc ƒë·ªÉ b·∫Øt ƒë·∫ßu Listening Preview.</div>';
        document.getElementById('pagination').classList.add('hide');
        return;
      }
      const lesson = lessons[currentLessonIdx];
      const data = lesson.sentence || [];
      const total = data.length;
      // clamp session range
      sessionStart = Math.max(0, Math.min(sessionStart, Math.max(0, total - 1)));
      sessionEnd = Math.max(sessionStart, Math.min(sessionEnd, total - 1));
      // ensure listeningIndex is within session
      listeningIndex = Math.max(sessionStart, Math.min(listeningIndex, sessionEnd));

      if (data.length === 0) {
        exerciseArea.innerHTML = '<div style="text-align:center; padding: 50px; color: var(--muted);">Kh√¥ng c√≥ c√¢u ƒë·ªÉ Preview trong b√†i h·ªçc n√†y.</div>';
        return;
      }

      document.getElementById('pagination').classList.remove('hide');

      // Per-listening controls removed ‚Äî centralized control bar handles playback/navigation.

      // Single live card showing the currently playing sentence
      const card = document.createElement('div');
      card.className = 'exercise-item';
      card.id = 'lp_current_card';
      card.innerHTML = `
        <div id="lp_eng" style="font-size:1.2rem; font-weight:700; color:#2563EB;"></div>
        <div id="lp_ipa" style="font-size:0.98rem; font-style:italic; color:#C586C0; margin-top:8px;"></div>
        <div id="lp_romaji" style="font-size:0.98rem; color:#C586C0; margin-top:6px;"></div>
        <div id="lp_vn" style="font-size:0.98rem; color:#12C07A; margin-top:8px;"></div>
      `;
      exerciseArea.appendChild(card);
      // center content for better readability
      card.style.display = 'flex';
      card.style.flexDirection = 'column';
      card.style.alignItems = 'center';
      card.style.justifyContent = 'center';
      card.style.textAlign = 'center';
      card.style.minHeight = '120px';

      updateListeningCard(listeningIndex);

      document.getElementById('pageInfo').textContent = `${listeningIndex - sessionStart + 1} / ${sessionEnd - sessionStart + 1} (t·ªïng ${total})`;

      // Central control bar handles listening actions including loop state.
    }

    function highlightListeningItem(idx) {
      // For single-card preview, update the displayed card
      updateListeningCard(idx);
    }

    function updateListeningCard(idx) {
      const lesson = lessons[currentLessonIdx] || {};
      const data = lesson.sentence || [];
      const item = data[idx] || {};
      const engEl = document.getElementById('lp_eng');
      const ipaEl = document.getElementById('lp_ipa');
      const romajiEl = document.getElementById('lp_romaji');
      const vnEl = document.getElementById('lp_vn');
      if (engEl) {
        engEl.innerHTML = `${idx+1}. ${item.prompt || item.answer || ''}`;
        engEl.style.textAlign = 'center';
        engEl.style.fontSize = '1.6rem';
      }
      if (ipaEl) { ipaEl.textContent = item.ipa || ''; ipaEl.style.textAlign = 'center'; ipaEl.style.marginTop = '6px'; }
      if (romajiEl) { romajiEl.textContent = item.romaji || ''; romajiEl.style.textAlign = 'center'; romajiEl.style.marginTop = '4px'; }
      if (vnEl) { vnEl.textContent = item.prompt_vi || ''; vnEl.style.textAlign = 'center'; vnEl.style.marginTop = '6px'; }
      listeningIndex = idx;
      const total = (lessons[currentLessonIdx] && lessons[currentLessonIdx].sentence) ? lessons[currentLessonIdx].sentence.length : 0;
      const pageInfo = document.getElementById('pageInfo');
      if (pageInfo) pageInfo.textContent = `${listeningIndex - sessionStart + 1} / ${sessionEnd - sessionStart + 1} (t·ªïng ${total})`;
    }

    function playPreviewAt(idx, sequential) {
      if (currentLessonIdx === -1) return;
      const lesson = lessons[currentLessonIdx] || {};
      const data = lesson.sentence || [];
      if (!data[idx]) return;
      // stop any current playback and clear cancel flag for new session
      try { if (currentHowl) { currentHowl.stop(); currentHowl.unload(); } } catch(e){}
      previewCanceled = false;
      isPreviewPlaying = true;
      listeningIndex = idx;
      highlightListeningItem(idx);

      const text = data[idx].prompt || data[idx].answer || '';
      // temporarily override global pauseSeconds
      const prevPause = pauseSeconds;
      pauseSeconds = listeningPauseSeconds;
      playAudioFor(text, () => {
        // if preview was canceled while audio was playing, abort any chained playback
        if (previewCanceled) {
          isPreviewPlaying = false;
          return;
        }
        // restore pause
        pauseSeconds = prevPause;
        // If auto-loop is enabled and we've reached the end, restart regardless of how playback was started
        if (idx === sessionEnd && listeningAutoLoop) {
          listeningIndex = sessionStart;
          updateListeningCard(listeningIndex);
          playPreviewAt(listeningIndex, true);
          return;
        }
        if (sequential) {
          if (idx < sessionEnd) {
            playPreviewAt(idx + 1, true);
          } else {
            isPreviewPlaying = false;
            // ensure UI reflects stopped state (update Play button if present)
            const playBtn = document.getElementById('lpPlay');
            if (playBtn) playBtn.textContent = '‚ñ∂ Ph√°t';
          }
        } else {
          isPreviewPlaying = false;
          const playBtn = document.getElementById('lpPlay');
          if (playBtn) playBtn.textContent = '‚ñ∂ Ph√°t';
        }
      });
    }

    function stopPreviewPlayback() {
      // mark canceled so any pending onComplete callbacks won't continue playback
      previewCanceled = true;
      isPreviewPlaying = false;
      try { if (currentHowl) { currentHowl.stop(); currentHowl.unload(); } } catch(e){}
      try { if (ttsAudio) { ttsAudio.pause(); ttsAudio.currentTime = 0; ttsAudio = null; } } catch(e){}
      // restart recognition if needed
      if (recognition && (isSpeakingMode || isReadingModeActive)) {
        try { if (!isRecognitionRunning) { recognition.start(); setStatus('ƒêang nghe...', 'green'); } } catch(e) { console.log('restart recognition failed', e); }
      } else {
        setStatus('Idle');
      }
    }

    function rewindPreview(seconds) {
      // Attempt to seek back `seconds` in current audio (Howl or TTS)
      try {
        if (currentHowl && typeof currentHowl.seek === 'function') {
          const pos = currentHowl.seek() || 0;
          const newPos = Math.max(0, pos - seconds);
          currentHowl.seek(newPos);
          return;
        }
      } catch (e) { console.log('Howl rewind failed', e); }
      try {
        if (ttsAudio && typeof ttsAudio.currentTime !== 'undefined') {
          ttsAudio.currentTime = Math.max(0, (ttsAudio.currentTime || 0) - seconds);
          return;
        }
      } catch (e) { console.log('TTS rewind failed', e); }
      // if no audio, as fallback, replay current sentence from start
      if (currentMode === 'listeningPreview') {
        playPreviewAt(listeningIndex, false);
      }
    }

    // Dictation renderer: play audio and ask user to type what they hear
    function renderDictation() {
      exerciseArea.innerHTML = '';
      if (currentLessonIdx === -1) {
        exerciseArea.innerHTML = '<div style="text-align:center; padding: 50px; color: var(--muted);">Vui l√≤ng ch·ªçn b√†i h·ªçc ƒë·ªÉ b·∫Øt ƒë·∫ßu Dictation.</div>';
        document.getElementById('pagination').classList.add('hide');
        return;
      }
      const lesson = lessons[currentLessonIdx];
      const data = lesson.sentence || [];
      const total = data.length;
      sessionStart = Math.max(0, Math.min(sessionStart, Math.max(0, total - 1)));
      sessionEnd = Math.max(sessionStart, Math.min(sessionEnd, total - 1));
      currentExIdx = Math.max(sessionStart, Math.min(currentExIdx, sessionEnd));
      if (data.length === 0) {
        exerciseArea.innerHTML = '<div style="text-align:center; padding: 50px; color: var(--muted);">Kh√¥ng c√≥ c√¢u ƒë·ªÉ luy·ªán Dictation trong b√†i h·ªçc n√†y.</div>';
        return;
      }
      document.getElementById('pagination').classList.remove('hide');

      const item = data[currentExIdx];
      const card = document.createElement('div');
      card.className = 'exercise-item';
      card.innerHTML = `
        <input type="text" id="dict_input" style="font-size:1.18rem; padding:14px; margin-top:12px;" placeholder="G√µ c√¢u b·∫°n nghe ƒë∆∞·ª£c..." autocomplete="off">
        <div class="feedback" id="fb_dict_${currentExIdx}"></div>
      `;
      exerciseArea.appendChild(card);
      document.getElementById('pageInfo').textContent = `${currentExIdx - sessionStart + 1} / ${sessionEnd - sessionStart + 1} (t·ªïng ${total})`;

      // No per-card Play button; centralPlay controls playback. Ensure input is visible.

      const input = document.getElementById('dict_input');
      if (input) {
        setTimeout(() => { try { input.focus(); } catch(e){} }, 80);
        input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            const val = input.value || '';
            const correct = item.answer_en || item.answer || item.prompt || '';
            const fb = document.getElementById(`fb_dict_${currentExIdx}`);
            const ok = checkLogic(val, correct);
            if (ok) {
              if (fb) { fb.className = 'feedback success'; fb.innerHTML = '‚úÖ Ch√≠nh x√°c!'; }
              playAudioFor(correct);
              clearTimeout(delayTimer);
              delayTimer = setTimeout(() => {
                if (currentExIdx < sessionEnd) {
                  currentExIdx++;
                  // schedule auto-play of next sentence
                  if (dictationAutoAdvance) dictationScheduledPlay = true;
                  renderDictation();
                }
                else {
                  if (sentenceAutoLoop) {
                    currentExIdx = sessionStart;
                    if (dictationAutoAdvance) dictationScheduledPlay = true;
                    renderDictation();
                  } else setStatus('Ho√†n th√†nh phi√™n', 'var(--muted)');
                }
              }, parseInt(delayRange.value));
            } else {
              if (fb) { fb.className = 'feedback error'; fb.innerHTML = `‚ùå Sai. ƒê√°p √°n: ${correct}`; }
              playAudioFor(correct);
            }
          }
        });
      }
      // If speaking mode is active, play the sentence then start recognition (allowing user to speak instead of typing)
      if (isSpeakingMode) {
        try { if (input) input.placeholder = 'üé§ N√≥i c√¢u b·∫°n nghe ƒë∆∞·ª£c...'; } catch(e){}
        const textToPlay = item.answer_en || item.answer || item.prompt || '';
        // ensure any previously scheduled auto-play doesn't conflict
        dictationScheduledPlay = false;
        // Wait until any current audio is idle, then play. Do NOT start recognition here;
        // `playAudioFor` will resume recognition after `pauseSeconds`, avoiding cutting audio.
        waitForAudioIdle().then(() => {
          try { const ii = document.getElementById('dict_input'); if (ii) { ii.focus(); ii.select(); } } catch(e){}
          playAudioFor(textToPlay, () => { try { const ii = document.getElementById('dict_input'); if (ii) { ii.focus(); } } catch(e){} });
        }).catch(() => {
          // fallback: play immediately if wait fails
          try { const ii = document.getElementById('dict_input'); if (ii) { ii.focus(); ii.select(); } } catch(e){}
          playAudioFor(textToPlay, () => { try { const ii = document.getElementById('dict_input'); if (ii) { ii.focus(); } } catch(e){} });
        });
      } else {
        // if a play was scheduled (from previous correct answer), perform it now
        if (dictationScheduledPlay) {
          dictationScheduledPlay = false;
          // Wait for any currently playing audio to finish before auto-playing next
          waitForAudioIdle().then(() => {
            // short delay to allow UI to settle
            setTimeout(() => {
              try {
                const textToPlay = item.answer_en || item.answer || item.prompt || '';
                try { const ii = document.getElementById('dict_input'); if (ii) { ii.focus(); ii.select(); } } catch(e){}
                playAudioFor(textToPlay);
                setTimeout(() => { try { const ii = document.getElementById('dict_input'); if (ii) ii.focus(); } catch(e){} }, 300);
              } catch (e) { console.warn('Auto-play dictation failed', e); }
            }, 180);
          }).catch(() => {/* ignore */});
        }
      }
    }

    // global keyboard shortcuts for Listening Preview, Reading Test and Role Playing
    window.addEventListener('keydown', (ev) => {
      // handle keys only when in listeningPreview, reading or roleplaying
      if (currentMode !== 'listeningPreview' && currentMode !== 'roleplaying' && currentMode !== 'reading') return;

      const centralPlayBtn = document.getElementById('centralPlay');

      // Role Playing: left/right for previous/next pair; Space or ArrowDown toggle play
      if (currentMode === 'roleplaying') {
        if (ev.key === 'ArrowLeft') {
          ev.preventDefault();
          try { if (window.rolePlayInstance) { window.rolePlayInstance.setState({ currentIndex: Math.max(0, (window.rolePlayInstance.state.currentIndex || 0) - 1) }); window.rolePlayInstance.processCurrentLine(); } } catch(e){}
        } else if (ev.key === 'ArrowRight') {
          ev.preventDefault();
          try { if (window.rolePlayInstance) { window.rolePlayInstance.setState({ currentIndex: (window.rolePlayInstance.state.currentIndex || 0) + 1 }); window.rolePlayInstance.processCurrentLine(); } } catch(e){}
        } else if (ev.key === 'ArrowDown' || ev.code === 'Space' || ev.key === ' ') {
          ev.preventDefault(); if (centralPlayBtn) centralPlayBtn.click();
        }
        return;
      }

      // Reading Test: map same navigation keys to reading actions
      if (currentMode === 'reading') {
        if (ev.key === 'ArrowLeft') {
          ev.preventDefault(); if (currentExIdx > sessionStart) { currentExIdx--; renderReading(); }
        } else if (ev.key === 'ArrowRight') {
          ev.preventDefault(); const lesson = lessons[currentLessonIdx] || {}; const data = (lesson.sentence || []); const maxIdx = Math.min(sessionEnd, data.length - 1); if (currentExIdx < maxIdx) { currentExIdx++; renderReading(); }
        } else if (ev.code === 'Space' || ev.key === ' ') {
          ev.preventDefault(); if (centralPlayBtn) centralPlayBtn.click();
        } else if (ev.key === 'ArrowUp') {
          ev.preventDefault(); const cRestartBtn = document.getElementById('centralRestart'); if (cRestartBtn) cRestartBtn.click(); currentExIdx = sessionStart; renderReading();
        } else if (ev.key === 'ArrowDown') {
          ev.preventDefault(); const cRepeatBtn = document.getElementById('centralRepeat'); if (cRepeatBtn) cRepeatBtn.click(); const lesson = lessons[currentLessonIdx] || {}; const item = (lesson.sentence||[])[currentExIdx]; if (item) playAudioFor(item.answer || item.prompt || '');
        } else if (ev.key.toLowerCase && ev.key.toLowerCase() === 'r') {
          ev.preventDefault(); currentExIdx = sessionStart; renderReading(); const pb = document.getElementById('lpPlay'); if (pb) pb.textContent = '‚è∏ D·ª´ng';
        }
        return;
      }

      // Listening Preview shortcuts
      if (ev.key === 'ArrowLeft') {
        ev.preventDefault(); if (listeningIndex > sessionStart) { playPreviewAt(listeningIndex - 1, false); }
      } else if (ev.key === 'ArrowRight') {
        ev.preventDefault(); if (listeningIndex < sessionEnd) { playPreviewAt(listeningIndex + 1, false); }
      } else if (ev.code === 'Space' || ev.key === ' ') {
        ev.preventDefault(); // toggle/play via central Play so labels stay in sync
        if (centralPlayBtn) centralPlayBtn.click();
      } else if (ev.key === 'ArrowUp') {
        ev.preventDefault(); // B·∫Øt ƒë·∫ßu l·∫°i: trigger centralRestart
        const cRestartBtn = document.getElementById('centralRestart'); if (cRestartBtn) cRestartBtn.click();
        // also reset listeningIndex and start playing from sessionStart
        listeningIndex = sessionStart;
        updateListeningCard(listeningIndex);
        playPreviewAt(listeningIndex, true);
      } else if (ev.key === 'ArrowDown') {
        ev.preventDefault(); // L·∫∑p l·∫°i: trigger centralRepeat
        const cRepeatBtn = document.getElementById('centralRepeat'); if (cRepeatBtn) cRepeatBtn.click();
        // If repeat means replay current item, play current index once
        playPreviewAt(listeningIndex, false);
      } else if (ev.key.toLowerCase && ev.key.toLowerCase() === 'r') {
        ev.preventDefault(); // legacy: restart session from sessionStart
        listeningIndex = sessionStart;
        updateListeningCard(listeningIndex);
        playPreviewAt(listeningIndex, true);
        const pb = document.getElementById('lpPlay'); if (pb) pb.textContent = '‚è∏ D·ª´ng';
      }
    });

    // --- Unified central control bar handlers ---
    (function wireCentralControls(){
      const cPrev = document.getElementById('centralPrev');
      const cNext = document.getElementById('centralNext');
      const cPlay = document.getElementById('centralPlay');
      const cRepeat = document.getElementById('centralRepeat');
      const cRestart = document.getElementById('centralRestart');
      const cLoop = document.getElementById('centralLoopCheckbox');

      function setPlayLabel(text){ if (cPlay) cPlay.textContent = text; }

      if (cPrev) cPrev.addEventListener('click', () => {
        if (currentMode === 'listeningPreview') {
          if (listeningIndex > sessionStart) { listeningIndex--; updateListeningCard(listeningIndex); playPreviewAt(listeningIndex, false); }
        } else if (currentMode === 'reading') {
          if (currentExIdx > sessionStart) { currentExIdx--; renderReading(); }
        } else if (currentMode === 'sentence') {
          if (currentExIdx > sessionStart) { currentExIdx--; render(); }
        } else if (currentMode === 'dictation') {
          if (currentExIdx > sessionStart) { currentExIdx--; renderDictation(); }
        } else if (currentMode === 'roleplaying') {
          try { if (window.rolePlayInstance) { window.rolePlayInstance.setState({ currentIndex: Math.max(0, (window.rolePlayInstance.state.currentIndex || 0) - 1) }); window.rolePlayInstance.processCurrentLine(); } } catch(e){}
        }
      });

      if (cNext) cNext.addEventListener('click', () => {
        if (currentMode === 'listeningPreview') {
          if (listeningIndex < sessionEnd) { listeningIndex++; updateListeningCard(listeningIndex); playPreviewAt(listeningIndex, false); }
        } else if (currentMode === 'reading') {
          const lesson = lessons[currentLessonIdx] || {};
          const data = (lesson.sentence || []);
          const maxIdx = Math.min(sessionEnd, data.length - 1);
          if (currentExIdx < maxIdx) { currentExIdx++; renderReading(); }
        } else if (currentMode === 'sentence') {
          const lesson = lessons[currentLessonIdx] || {};
          const data = (lesson.sentence || []);
          const maxIdx = Math.min(sessionEnd, data.length - 1);
          if (currentExIdx < maxIdx) { currentExIdx++; render(); }
        } else if (currentMode === 'dictation') {
          const lesson = lessons[currentLessonIdx] || {};
          const data = (lesson.sentence || []);
          const maxIdx = Math.min(sessionEnd, data.length - 1);
          if (currentExIdx < maxIdx) { currentExIdx++; renderDictation(); }
        } else if (currentMode === 'roleplaying') {
          try { if (window.rolePlayInstance) { window.rolePlayInstance.setState({ currentIndex: (window.rolePlayInstance.state.currentIndex || 0) + 1 }); window.rolePlayInstance.processCurrentLine(); } } catch(e){}
        }
      });

      if (cPlay) cPlay.addEventListener('click', () => {
        if (currentMode === 'listeningPreview') {
          if (!isPreviewPlaying) { playPreviewAt(listeningIndex, true); setPlayLabel('‚è∏ D·ª´ng'); }
          else { stopPreviewPlayback(); setPlayLabel('‚ñ∂ Ph√°t'); }
        } else if (currentMode === 'reading') {
          // toggle reading test start/stop by clicking the readingToggle if present
          const btn = document.getElementById('readingToggle');
          if (btn) { btn.click(); setPlayLabel(isReadingModeActive ? '‚ñ∂ Ph√°t' : '‚è∏ D·ª´ng'); }
          else {
            // fallback: toggle recognition
            if (!recognition) initSpeechRecognition();
            if (!isReadingModeActive) { isReadingModeActive = true; try { if (!isRecognitionRunning) recognition.start(); } catch(e){}; setStatus('ƒêang nghe...', 'green'); setPlayLabel('‚è∏ D·ª´ng'); }
            else { isReadingModeActive = false; try { recognition.stop(); } catch(e){}; setStatus('Idle'); setPlayLabel('‚ñ∂ Ph√°t'); }
          }
        } else if (currentMode === 'sentence') {
          // play answer audio for current sentence
          if (currentLessonIdx === -1) return;
          const lesson = lessons[currentLessonIdx] || {};
          const data = lesson.sentence || [];
          const item = data[currentExIdx];
          if (!item) return;
          const ans = item.answer_en || item.answer || item.prompt || '';
          playAudioFor(ans);
        } else if (currentMode === 'dictation') {
          if (currentLessonIdx === -1) return;
          const lesson = lessons[currentLessonIdx] || {};
          const data = lesson.sentence || [];
          const item = data[currentExIdx];
          if (!item) return;
          const ans = item.answer_en || item.answer || item.prompt || '';
          // focus input before playback
          try { const inp = document.getElementById('dict_input'); if (inp) { inp.focus(); inp.select(); } } catch(e){}
          playAudioFor(ans);
          // ensure focus after a short delay (playback may steal focus)
          setTimeout(() => { try { const inp = document.getElementById('dict_input'); if (inp) inp.focus(); } catch(e){} }, 300);
        } else if (currentMode === 'roleplaying') {
          try { if (window.rolePlayInstance) { window.rolePlayInstance.toggleAutoPlay(); setPlayLabel(window.rolePlayInstance.state.isAutoPlaying ? '‚è∏ D·ª´ng' : '‚ñ∂ Ph√°t'); } } catch(e){}
        }
      });

      if (cRepeat) cRepeat.addEventListener('click', () => {
        if (currentMode === 'listeningPreview') { playPreviewAt(listeningIndex, false); }
        else if (currentMode === 'reading') { const lesson = lessons[currentLessonIdx] || {}; const item = (lesson.sentence||[])[currentExIdx]; if (item) playAudioFor(item.answer || item.prompt || ''); }
        else if (currentMode === 'sentence') { const lesson = lessons[currentLessonIdx] || {}; const item = (lesson.sentence||[])[currentExIdx]; if (item) playAudioFor(item.answer || item.prompt || ''); }
        else if (currentMode === 'dictation') { const lesson = lessons[currentLessonIdx] || {}; const item = (lesson.sentence||[])[currentExIdx]; if (item) playAudioFor(item.answer || item.prompt || ''); }
        else if (currentMode === 'roleplaying') {
          try {
            // Play sample for the partner/closed role of the current pair (keep label 'L·∫∑p l·∫°i')
            if (window.rolePlayInstance && typeof window.rolePlayInstance.playPartnerSample === 'function') {
              window.rolePlayInstance.playPartnerSample();
            } else if (window.rolePlayInstance && typeof window.rolePlayInstance.replayCurrentLine === 'function') {
              // fallback to previous behaviour
              window.rolePlayInstance.replayCurrentLine();
            }
          } catch (e) { console.warn('centralRepeat roleplaying handler failed', e); }
        }
      });

      if (cRestart) cRestart.addEventListener('click', () => {
        if (currentMode === 'listeningPreview') { listeningIndex = sessionStart; updateListeningCard(listeningIndex); playPreviewAt(listeningIndex, true); setPlayLabel('‚è∏ D·ª´ng'); }
        else if (currentMode === 'reading') { currentExIdx = sessionStart; renderReading(); if (!isReadingModeActive) { /* do not auto-start recognition */ } }
        else if (currentMode === 'sentence') { currentExIdx = sessionStart; render(); }
        else if (currentMode === 'dictation') { currentExIdx = sessionStart; renderDictation(); }
        else if (currentMode === 'roleplaying') { try { if (window.rolePlayInstance) window.rolePlayInstance.resetSession(); } catch(e){} }
      });

      // rewind control removed ‚Äî users don't use -3s

      if (cLoop) cLoop.addEventListener('change', (e) => {
        const val = !!e.target.checked;
        listeningAutoLoop = val; readingAutoLoop = val; sentenceAutoLoop = val;
        const globalAuto = document.getElementById('listLoopCheckbox'); if (globalAuto) globalAuto.checked = val;
        // update any local lp checkbox if present
        const lpAuto = document.getElementById('lpAutoLoop'); if (lpAuto) lpAuto.checked = val;
      });
    })();

    function renderItem(item, idx, total) {
      if (!item) return;
      const div = document.createElement('div');
      div.className = 'exercise-item';
      const answer = item.answer_en || item.answer;
      const mainText = item.prompt || item.answer || '';
      const ipaLine = item.ipa || '';
      const romajiLine = item.romaji || '';
      const viLine = item.prompt_vi || '';
      const inputId = `input_${idx}`;

      div.innerHTML = `
        <div class="question" style="font-size:1.6rem;">${idx + 1}. ${mainText}</div>
        <div class="ipa">${ipaLine || romajiLine}</div>
        <div class="vn">${romajiLine && ipaLine ? romajiLine : ''}${romajiLine && ipaLine ? '' : ''}</div>
        <div class="vn">${viLine}</div>
        <input type="text" id="${inputId}" style="font-size:1.18rem; padding:14px;" placeholder="${isSpeakingMode ? 'üé§ ƒêang nghe... h√£y n√≥i' : 'Nh·∫≠p c√¢u tr·∫£ l·ªùi...'}" autocomplete="off">
        <div class="feedback" id="fb_${idx}"></div>
      `;
      exerciseArea.appendChild(div);

      // Make Writing Test card match Listening Preview dimensions and spacing
      div.style.display = 'flex';
      div.style.flexDirection = 'column';
      div.style.alignItems = 'center';
      div.style.justifyContent = 'center';
      div.style.textAlign = 'center';
      div.style.minHeight = '120px';
      div.style.padding = '12px';

      // Tighter styles for input to reduce card height
      const inputEl = document.getElementById(inputId);
      if (inputEl) {
        inputEl.style.padding = '10px';
        inputEl.style.fontSize = '1.02rem';
        inputEl.style.width = '90%';
      }

      const input = document.getElementById(inputId);
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          clearTimeout(delayTimer);
          const textToSpeak = answer;
          playAudioFor(textToSpeak);

          const isCorrect = checkLogic(input.value, answer);
          const fb = document.getElementById(`fb_${idx}`);
          
          if (isCorrect) {
            const viTrans = item.prompt_vi || "";
            fb.className = 'feedback success';
            fb.innerHTML = `‚úÖ Ch√≠nh x√°c!${viTrans ? `<br><span class="translation-hint"> Nghƒ©a: ${viTrans}</span>` : ''}`;
            
            delayTimer = setTimeout(() => {
              if (isSingleMode) {
                // advance within the session range, not the full lesson
                if (currentExIdx < sessionEnd) {
                  currentExIdx++; render();
                } else {
                  // reached end of session
                  if (sentenceAutoLoop) {
                    currentExIdx = sessionStart; render();
                  } else {
                    setStatus('Ho√†n th√†nh phi√™n', 'var(--muted)');
                  }
                }
              } else {
                const nextInput = document.getElementById(`input_${idx + 1}`);
                if (nextInput) { nextInput.scrollIntoView({ behavior: 'smooth', block: 'center' }); nextInput.focus(); }
              }
            }, parseInt(delayRange.value));
          } else {
            fb.className = 'feedback error';
            fb.textContent = `‚ùå Ch∆∞a ƒë√∫ng! ƒê√°p √°n: ${answer}`;
          }
        }
      });
    }

    function checkLogic(userVal, correctVal) {
      return similarity(userVal, correctVal) >= matchThreshold;
    }

    function playAudioFor(text, onComplete) {
      if (!text) {
        if (typeof onComplete === 'function') onComplete();
        return;
      }
      const entry = resolveAudioEntry(text);
      if (entry && entry.file) {
        const path = ('LESSON/' + entry.file).replace(/\\/g, '/').replace(/\\/g, '/');
        try { if (currentHowl) { currentHowl.stop(); currentHowl.unload(); } } catch(e){}
        // if recognition is active and in speaking/reading mode, stop it temporarily to avoid self-detection
        if (recognition && (isSpeakingMode || isReadingModeActive)) {
          willRestartRecognition = true;
          try { recognition.stop(); } catch(e) { console.log('stop recognition failed', e); }
        }
        setStatus('ƒêang ph√°t...', 'var(--primary)');
        currentHowl = new Howl({ src: [path], html5: true, onend: function() {
          // after playback, show waiting period for user to read answer
          setStatus(`ƒêang ch·ªù ${pauseSeconds}s`, 'var(--accent)');
          setTimeout(() => {
            // call completion callback before restarting recognition so UI can update
            if (typeof onComplete === 'function') {
              try { onComplete(); } catch (e) { console.log('onComplete error', e); }
            }
            willRestartRecognition = false;
            if (recognition && (isSpeakingMode || isReadingModeActive)) {
              try { if (!isRecognitionRunning) { recognition.start(); setStatus('ƒêang nghe...', 'green'); } } catch(e) { console.log('restart recognition failed', e); setStatus('L·ªói nghe', 'var(--error)'); }
            } else {
              setStatus('Idle');
            }
          }, pauseSeconds * 1000);
        }});
        currentHowl.play();
        return;
      }
      // fallback to TTS
      // stop recognition briefly for TTS playback as well
      if (recognition && (isSpeakingMode || isReadingModeActive)) {
        willRestartRecognition = true;
        try { recognition.stop(); } catch(e) { console.log('stop recognition failed', e); }
      }
      setStatus('ƒêang ph√°t...', 'var(--primary)');
      speak(text, () => {
        // after TTS finished, wait pauseSeconds before calling completion and resuming recognition
        setStatus(`ƒêang ch·ªù ${pauseSeconds}s`, 'var(--accent)');
        setTimeout(() => {
          if (typeof onComplete === 'function') {
            try { onComplete(); } catch (e) { console.log('onComplete error', e); }
          }
          willRestartRecognition = false;
          if (recognition && (isSpeakingMode || isReadingModeActive)) {
            try { if (!isRecognitionRunning) { recognition.start(); setStatus('ƒêang nghe...', 'green'); } } catch(e) { console.log('restart recognition failed', e); setStatus('L·ªói nghe', 'var(--error)'); }
          } else {
            setStatus('Idle');
          }
        }, pauseSeconds * 1000);
      });
    }

    function getSelectedEngine() {
      const sel = document.getElementById('audioEngineSelect');
      if (!sel) return localStorage.getItem('preferred_tts_engine') || 'gTTS';
      return sel.value || (localStorage.getItem('preferred_tts_engine') || 'gTTS');
    }

    function resolveAudioEntry(text) {
      if (!text) return null;
      const trimmed = text.toString().trim();
      const preferred = getSelectedEngine();
      // prefer mapping that matches both text and engine
      let entry = audioMapping.find(it => it.text && it.text.toString().trim() === trimmed && it.engine === preferred);
      if (entry) return entry;
      // fallback: any entry that matches text regardless engine
      entry = audioMapping.find(it => it.text && it.text.toString().trim() === trimmed);
      return entry || null;
    }

    function speak(text, onEnded) {
      if (!text) {
        if (typeof onEnded === 'function') onEnded();
        return;
      }
      const url = `https://translate.google.com/translate_tts?ie=UTF-8&tl=en&client=tw-ob&q=${encodeURIComponent(text)}`;
      try {
        // create global ttsAudio so we can seek/rewind
        if (ttsAudio) {
          try { ttsAudio.pause(); } catch(e){}
          ttsAudio = null;
        }
        ttsAudio = new Audio(url);
        ttsAudio.crossOrigin = 'anonymous';
        ttsAudio.play().catch(e => console.log("Audio play blocked", e));
        ttsAudio.onended = function() { ttsAudio = null; if (typeof onEnded === 'function') onEnded(); };
      } catch (e) {
        console.log('TTS play error', e);
        ttsAudio = null;
        if (typeof onEnded === 'function') onEnded();
      }
    }

    // Wait until current audio (Howl or ttsAudio) is idle before resolving
    function waitForAudioIdle(timeout = 15000) {
      return new Promise((resolve) => {
        const start = Date.now();
        const check = () => {
          try {
            // If Howl is playing
            if (currentHowl && typeof currentHowl.playing === 'function' && currentHowl.playing()) {
              // still playing
            } else if (ttsAudio && !ttsAudio.paused) {
              // TTS playing
            } else {
              resolve(); return;
            }
          } catch (e) { resolve(); return; }
          if (Date.now() - start > timeout) { resolve(); return; }
          setTimeout(check, 180);
        };
        check();
      });
    }

    // prevEx / nextEx removed ‚Äî use the unified central control bar instead
    // populate server lesson list on load
    loadLessonList();
  </script>
  <!-- Role Playing app styles and script (from role_playing.html) -->
  <style>
    /* RolePlay styles appended to integrate role_playing.html design */
    :root {
      --page-bg-color: #1e1e1e;
      --bg: linear-gradient(180deg,#1e1e1e 0%, #181818 100%);
      --card-bg: #252526;
      --text: #d4d4d4;
      --muted: #9a9a9a;
      --primary: #569cd6;
      --accent: #c586c0;
      --success: #6a9955;
      --error: #f44747;
      --glass: rgba(255,255,255,0.02);
      --shadow: 0 10px 26px rgba(0,0,0,0.6);
      --soft-shadow: 0 6px 14px rgba(0,0,0,0.5);
      --border: rgba(255,255,255,0.02);
      --radius: 12px;
    }
    .roleplay-container * { box-sizing: border-box; }
    .roleplay-container body { margin:0; }
    .roleplay-container { text-align: center; }
    .roleplay-container .container { max-width:1100px; margin: 36px auto; padding: 20px; width:100%; }
    .roleplay-container header { display:flex; align-items:center; justify-content:space-between; margin-bottom:12px; }
    .roleplay-container .logo { width:48px; height:48px; background:linear-gradient(135deg,var(--primary),var(--accent)); border-radius:10px; display:flex; align-items:center; justify-content:center; color:#071022; font-weight:800; font-size:1rem; box-shadow:var(--soft-shadow); }
    .roleplay-container .control-panel { display:flex; flex-wrap:wrap; gap:8px; background:var(--card-bg); padding:8px 10px; border-radius:8px; box-shadow:var(--soft-shadow); border:1px solid var(--border); align-items:center; width:100%; max-width:1100px; margin:0 auto; }
    .roleplay-container .control-panel { position: -webkit-sticky; position: sticky; top: 20px; z-index:50; }
    .roleplay-container main { width:100%; max-width:1100px; margin:0 auto; }
    .roleplay-container .exercise-item { width: 100%; }
    .roleplay-container .option-group { display:flex; align-items:center; gap:8px; font-weight:600; font-size:0.88rem; }
    .roleplay-container select, .roleplay-container input[type=range] { padding:8px; border-radius:6px; background:var(--card-bg); color:var(--text); border:1px solid var(--border); }
    .roleplay-container .btn { border:none; border-radius:8px; padding:8px 12px; font-weight:700; cursor:pointer; background:linear-gradient(90deg,var(--primary),#4fc3f7); color:#071022; }
    .roleplay-container .btn.ghost { background:transparent; border:1px solid rgba(255,255,255,0.04); color:var(--text); }
    .roleplay-container .exercise-item {
      /* Reduced height: smaller padding and top-aligned content */
      background: var(--card-bg);
      padding: 16px 20px;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      border: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      text-align: center;
      width: 100%;
      min-height: 80px;
      margin: 0 0 20px 0;
      overflow: visible;
    }
    .roleplay-container .question { font-size:1.6rem; font-weight:700; margin-bottom:6px; text-align:center; color: #2563EB; }
    .roleplay-container .vietnamese { font-style:italic; color:#12C07A; margin-bottom:15px; text-align:center; }
    .roleplay-container .translation-hint { color:#C586C0; font-weight:600; font-style:italic; display:block; margin-top:8px; text-align:center; }
    .roleplay-container .feedback { margin-top:10px; padding:10px; border-radius:8px; min-height:20px; font-weight:600; text-align:center; }
    .roleplay-container .feedback.success { color:var(--success); background:rgba(46,204,113,0.06); }
    .roleplay-container .feedback.error { color:var(--error); background:rgba(231,76,60,0.06); }
    .roleplay-container .hide { display:none; }
    /* Ensure active-mode styling wins over .btn.ghost in roleplay area */
    .roleplay-container .btn.active-mode {
      background: linear-gradient(90deg,var(--success),#12c07a) !important;
      color: white !important;
      box-shadow: 0 8px 24px rgba(18,160,80,0.12) !important;
    }
    /* Ensure RolePlay layout matches other tabs */
    .roleplay-container main { flex: 1; }
    .roleplay-container .question { font-size:1.6rem; line-height:1.05; margin:6px 0; text-align:center; }
    .roleplay-container #rp_ipa { font-size:0.98rem; margin-top:6px; text-align:center; color: #C586C0; }
    .roleplay-container #rp_vn { font-size:0.98rem; margin-top:6px; text-align:center; color: #12C07A; }
    .roleplay-container .control-panel { margin-top:12px; display:flex; flex-direction:column; gap:8px; padding-top:8px; }
    .roleplay-container { width:100%; padding:0; margin:0; }
    /* Ensure the rolePlayingArea doesn't add extra gap when shown */
    #rolePlayingArea { margin-top: 0 !important; padding-top: 0 !important; }
    /* Pull the roleplay container up to sit directly under the control bar */
    .roleplay-container { margin-top: 0 !important; }
    .roleplay-container .rp-page-info { text-align:center; margin-top:12px; font-weight:700; }
  </style>

  <script type="module">
      // --- MAIN APPLICATION ---
      class RolePlayApp {
        constructor() {
          this.state = {
            appState: 'SETUP', // SETUP, LOADING, PLAYING
            userRole: 'A', // A speaks first, B speaks second, 'AB' for shadowing
            currentIndex: 0,
            feedback: { type: 'neutral', message: 'S·∫µn s√†ng...' },
            isProcessingAI: false,
            isAutoPlaying: false,
            transcript: '',
            isListening: false,
            
            // Lesson data
            availableLessons: [],
            currentLesson: null,
            scriptLines: [],
            originalScriptLines: [],
            audioBasePath: '',
            audioCache: new Map(),
            
            // UI state
            // -1 means no lesson selected (show placeholder in selector)
            selectedLessonIndex: -1,
            startPair: null,
            endPair: null,
            attempts: 0,
            
            // Progress tracking
            currentPair: 1,
            totalPairs: 0,
            
            // Shadowing mode
            shadowDelay: 0, // Delay in ms before user speaks in shadowing mode
            // Delay before starting recognition on user's turn (ms)
            userReplyDelay: 50,
            // UI flag when waiting for user reply (shows colored hint instead of re-rendering)
            waitingForUser: false,
            isShadowingActive: false,
            
            // Speech recognition settings
            difficulty: 'normal', // 'easy', 'normal', 'hard'
            matchingThreshold: 0.95, // Default 95% (max)
            maxAttempts: 3,
            customThreshold: true,
            // Voice selection (single voice for both roles)
            voice1: 'gTTS',
            
            // Accuracy tracking
            accuracyStats: {
              totalAttempts: 0,
              successful: 0,
              failed: 0,
              accuracy: 0,
              sessionAccuracy: 0,
              commonErrors: []
            },
            
            // Pronunciation patterns for Vietnamese speakers
            pronunciationPatterns: {
              'th': ['d', 't', 's'], // Vietnamese often pronounce "th" as "d", "t", or "s"
              'v': ['b'], // "v" as "b"
              'z': ['s'], // "z" as "s"
              ' É': ['s'], // "sh" as "s"
              ' í': ['z'], // "zh" as "z"
              '√∞': ['d'], // "th" in "the" as "d"
              'Œ∏': ['t'], // "th" in "think" as "t"
              'l': ['n'], // Sometimes "l" as "n"
              'r': ['z'], // "r" as "z" in some accents
              '√¶': ['a'], // "cat" vowel
              ' å': ['a'], // "cup" vowel
            }
          };

          // Ensure any pre-existing matchingThreshold above 95% is clamped
          if (this.state.matchingThreshold > 0.95) {
            this.state.matchingThreshold = 0.95;
            this.state.customThreshold = true;
          }

          this.audioContext = null;
          this.speechRecognition = this.initSpeechRecognition();
          this.loadAvailableLessons();
        }

        // --- INITIALIZE ---
        async loadAvailableLessons() {
          try {
            const response = await fetch('json_list.json');
            if (!response.ok) throw new Error(`Kh√¥ng th·ªÉ t·∫£i danh s√°ch b√†i h·ªçc: ${response.status}`);
            
            const data = await response.json();
            this.setState({ 
              availableLessons: data.lessons || [],
              feedback: { type: 'success', message: `ƒê√£ t·∫£i ${data.lessons?.length || 0} b√†i h·ªçc` }
            });
          } catch (error) {
            console.error('L·ªói t·∫£i danh s√°ch b√†i h·ªçc:', error);
            this.setState({ 
              feedback: { type: 'error', message: 'Kh√¥ng th·ªÉ t·∫£i danh s√°ch b√†i h·ªçc' },
              availableLessons: []
            });
          }
        }

        getAudioContext() {
          if (!this.audioContext) {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          }
          if (this.audioContext.state === 'suspended') {
            this.audioContext.resume();
          }
          return this.audioContext;
        }

        initSpeechRecognition() {
          const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
          if (!SpeechRecognition) {
            console.warn('Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Speech Recognition');
            return null;
          }
          
          const recognition = new SpeechRecognition();
          recognition.continuous = false;
          recognition.interimResults = true;
          recognition.lang = 'en-US';
          
          recognition.onstart = () => {
            // When recognition actually starts, show a clear prompt so user knows mic is ready
            try {
              const showingUserTurn = this.state.waitingForUser || this.state.userRole === 'AB' || this.state.isAutoPlaying;
              if (showingUserTurn) {
                this.setState({ isListening: true, feedback: { type: 'neutral', message: 'Th·ª≠ n√≥i l·∫°i' } });
              } else {
                // keep a lightweight flag without re-render when not relevant
                this.setState({ isListening: true }, true);
              }
            } catch (e) { this.setState({ isListening: true }, true); }
          };
          recognition.onresult = (event) => {
            let finalTranscript = '';
            let interimTranscript = '';
            
            for (let i = event.resultIndex; i < event.results.length; ++i) {
              if (event.results[i].isFinal) {
                finalTranscript += event.results[i][0].transcript;
              } else {
                interimTranscript += event.results[i][0].transcript;
              }
            }
            
            // Show interim results
              if (interimTranscript) {
                // update transcript without triggering a full re-render to avoid UI jitter
                this.setState({ transcript: interimTranscript }, true);
              }
            
            if (finalTranscript) {
              this.setState({ transcript: finalTranscript });
              this.checkTranscript(finalTranscript);
            }
          };
          recognition.onend = () => this.setState({ isListening: false }, true);
          recognition.onerror = (event) => {
            console.error('Speech recognition error', event.error);
            this.setState({ isListening: false });
          
            // Auto-advance on no-speech error
            if (event.error === 'no-speech') {
              setTimeout(() => {
                this.setState({
                  currentIndex: this.state.currentIndex + 1,
                  currentPair: Math.floor((this.state.currentIndex + 1) / 2) + 1,
                  feedback: { type: 'error', message: 'Kh√¥ng nghe th·∫•y gi·ªçng n√≥i. T·ª± ƒë·ªông chuy·ªÉn ti·∫øp...' }
                });
                this.processCurrentLine();
              }, 2000);
            }
          };
          
          return recognition;
        }

        // --- IMPROVED SPEECH RECOGNITION MATCHING ---
        calculateSimilarity(str1, str2) {
          // Simple similarity calculation based on word overlap
          const words1 = str1.toLowerCase().split(/\s+/);
          const words2 = str2.toLowerCase().split(/\s+/);
          
          const intersection = words1.filter(word => 
            words2.some(w2 => this.wordsSimilar(word, w2))
          );
          
          return intersection.length / Math.max(words1.length, words2.length);
        }

        wordsSimilar(word1, word2) {
          // Check if words are similar (including common pronunciation errors)
          if (word1 === word2) return true;
          
          // Check for common Vietnamese pronunciation patterns
          for (const [correct, mistakes] of Object.entries(this.state.pronunciationPatterns)) {
            if (word2.includes(correct)) {
              for (const mistake of mistakes) {
                const variant = word2.replace(new RegExp(correct, 'g'), mistake);
                if (word1 === variant || variant.includes(word1) || word1.includes(variant)) {
                  return true;
                }
              }
            }
          }
          
          // Check for partial matches
          if (word1.includes(word2) || word2.includes(word1)) {
            return true;
          }
          
          // Check for similar length and characters
          if (Math.abs(word1.length - word2.length) <= 2) {
            const commonChars = word1.split('').filter(char => word2.includes(char)).length;
            const similarity = commonChars / Math.max(word1.length, word2.length);
            return similarity > 0.6;
          }
          
          return false;
        }

        extractKeywords(text) {
          // Extract important words (excluding common words)
          const commonWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by'];
          const words = text.toLowerCase().split(/\s+/);
          return words.filter(word => 
            word.length > 2 && !commonWords.includes(word)
          );
        }

        checkKeywords(userText, keywords) {
          if (keywords.length === 0) return 1;
          
          const userWords = userText.toLowerCase().split(/\s+/);
          const matchedKeywords = keywords.filter(keyword =>
            userWords.some(userWord => this.wordsSimilar(userWord, keyword))
          );
          
          return matchedKeywords.length / keywords.length;
        }

        getMatchingThreshold() {
          // If user set a custom threshold via UI slider, use it
          if (this.state.customThreshold) {
            return this.state.matchingThreshold;
          }

          // Return threshold based on difficulty
          const thresholds = {
            'easy': 0.3,
            'normal': 0.4,
            'hard': 0.6,
            'shadowing': 0.2
          };

          if (this.state.userRole === 'AB') {
            return thresholds.shadowing;
          }

          return thresholds[this.state.difficulty] || 0.4;
        }

        getMaxAttempts() {
          // Return max attempts based on difficulty
          const attempts = {
            'easy': 5,
            'normal': 3,
            'hard': 2,
            'shadowing': 3  // Increased from 1 to 3 for better practice
          };
          
          if (this.state.userRole === 'AB') {
            return attempts.shadowing;
          }
          
          return attempts[this.state.difficulty] || 3;
        }

        // --- UPDATED CHECK TRANSCRIPT METHOD ---
        checkTranscript(transcript) {
          const currentLine = this.state.scriptLines[this.state.currentIndex];
          if (!currentLine) return;
          
          // For shadowing mode, user always speaks
          const isCorrectUser = this.state.userRole === 'AB' ? true : currentLine.role === this.state.userRole;
          if (!isCorrectUser) return;
          
          // Update accuracy stats
          this.state.accuracyStats.totalAttempts++;
          
          // Calculate multiple similarity scores
          const userText = transcript.toLowerCase().replace(/[^\w\s]/g, '');
          const targetText = currentLine.text.toLowerCase().replace(/[^\w\s]/g, '');
          
          // 1. Full text similarity
          const fullSimilarity = this.calculateSimilarity(userText, targetText);
          
          // 2. Keyword matching
          const keywords = this.extractKeywords(targetText);
          const keywordScore = this.checkKeywords(userText, keywords);
          
          // 3. Combined score (weighted) - stricter for shadowing
          const keywordWeight = this.state.userRole === 'AB' ? 0.1 : 0.3;
          const fullWeight = 1 - keywordWeight;
          const combinedScore = (fullSimilarity * fullWeight) + (keywordScore * keywordWeight);
          
          // Get current threshold
          const threshold = this.getMatchingThreshold();
          const maxAttempts = this.getMaxAttempts();
          
          // Show similarity percentage in feedback
          const similarityPercent = Math.round(combinedScore * 100);
          
          if (combinedScore > threshold) {
            // Success!
            if (this.speechRecognition) this.speechRecognition.stop();
            
            this.state.accuracyStats.successful++;
            this.updateAccuracy();
            
            this.setState({
              feedback: { 
                type: 'success', 
                message: `T·ªët!`
              },
              isListening: false,
              waitingForUser: false,
              attempts: 0
            });
            
            // Record successful attempt
            this.recordAttempt(transcript, currentLine.text, true, similarityPercent);
            
            // Advance to next line after success
            setTimeout(() => {
              this.setState({
                currentIndex: this.state.currentIndex + 1,
                currentPair: Math.floor((this.state.currentIndex + 1) / 2) + 1,
                transcript: ''
              });
              this.processCurrentLine();
            }, 1200);
          } else {
            // Not accurate enough
            this.state.accuracyStats.failed++;
            this.updateAccuracy();
            
            this.setState({ attempts: this.state.attempts + 1 });
            
            // Record failed attempt
            this.recordAttempt(transcript, currentLine.text, false, similarityPercent);
            
            if (this.state.attempts >= maxAttempts) {
              // Too many attempts, advance anyway
              if (this.speechRecognition) this.speechRecognition.stop();
              this.setState({
                feedback: { type: 'error', message: 'Th·ª≠ n√≥i l·∫°i' },
                isListening: false,
                waitingForUser: false,
                attempts: 0,
                currentIndex: this.state.currentIndex + 1,
                currentPair: Math.floor((this.state.currentIndex + 1) / 2) + 1,
                transcript: ''
              });
              setTimeout(() => this.processCurrentLine(), 2000);
            } else {
              const remainingAttempts = maxAttempts - this.state.attempts;
              // Show concise prompt to retry
              this.setState({ feedback: { type: 'error', message: 'Th·ª≠ n√≥i l·∫°i' } });
              
              // Show what was mispronounced
              this.showMispronunciation(transcript, currentLine.text);
              
              // Play the correct audio again
              setTimeout(async () => {
                if (currentLine.audioFile) {
                  try {
                    await this.playAudio(currentLine.audioFile);
                  } catch (error) {
                    console.error('L·ªói ph√°t l·∫°i audio:', error);
                  }
                }
                
                // Restart listening (keep waitingForUser true)
                setTimeout(() => {
                  if (this.state.isAutoPlaying && this.speechRecognition) {
                    if (!this.state.isListening) {
                      try { this.speechRecognition.start(); } catch (e) { console.warn('Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu nh·∫≠n di·ªán:', e); }
                    } else {
                      console.warn('SpeechRecognition already running, skip start');
                    }
                  }
                }, 500);
              }, 1000);
            }
          }
        }

        showMispronunciation(userText, targetText) {
          // Simple mispronunciation detection
          const userWords = userText.toLowerCase().split(/\s+/);
          const targetWords = targetText.toLowerCase().split(/\s+/);
          
          const missingWords = targetWords.filter(word => 
            !userWords.some(uWord => this.wordsSimilar(uWord, word))
          );
          
          if (missingWords.length > 0) {
            console.log('T·ª´ b·ªã thi·∫øu/sai:', missingWords.join(', '));
            // Could show this in UI
          }
        }

        recordAttempt(userText, targetText, isSuccess, accuracyPercent) {
          // Record attempt for statistics
          const attempt = {
            timestamp: new Date().toISOString(),
            userText,
            targetText,
            isSuccess,
            accuracyPercent,
            difficulty: this.state.difficulty
          };
          
          // Store in localStorage for persistence
          const attempts = JSON.parse(localStorage.getItem('speechAttempts') || '[]');
          attempts.push(attempt);
          if (attempts.length > 100) attempts.shift(); // Keep only last 100
          localStorage.setItem('speechAttempts', JSON.stringify(attempts));
        }

        updateAccuracy() {
          const { totalAttempts, successful } = this.state.accuracyStats;
          if (totalAttempts > 0) {
            this.state.accuracyStats.accuracy = (successful / totalAttempts) * 100;
            
            // Calculate session accuracy (last 10 attempts)
            const attempts = JSON.parse(localStorage.getItem('speechAttempts') || '[]');
            const recentAttempts = attempts.slice(-10);
            if (recentAttempts.length > 0) {
              const recentSuccesses = recentAttempts.filter(a => a.isSuccess).length;
              this.state.accuracyStats.sessionAccuracy = (recentSuccesses / recentAttempts.length) * 100;
            }
          }
        }

        getAccuracyColor(accuracy) {
          if (accuracy >= 70) return 'accuracy-high';
          if (accuracy >= 40) return 'accuracy-medium';
          return 'accuracy-low';
        }

        // --- LOAD LESSON ---
        async loadSelectedLesson() {
          if (this.state.availableLessons.length === 0) return;
          if (typeof this.state.selectedLessonIndex !== 'number' || this.state.selectedLessonIndex < 0 || this.state.selectedLessonIndex >= this.state.availableLessons.length) {
            // no valid lesson selected
            this.setState({ feedback: { type: 'error', message: 'Vui l√≤ng ch·ªçn b√†i h·ªçc' } });
            return;
          }

          const lesson = this.state.availableLessons[this.state.selectedLessonIndex];
          this.setState({ 
            appState: 'LOADING',
            feedback: { type: 'neutral', message: `ƒêang t·∫£i b√†i h·ªçc: ${lesson.name}...` }
          });

          try {
            // 1. Load the main lesson JSON
            const lessonResponse = await fetch(`LESSON/${lesson.name}`);
            if (!lessonResponse.ok) throw new Error(`Kh√¥ng th·ªÉ t·∫£i file b√†i h·ªçc: ${lessonResponse.status}`);
            const lessonData = await lessonResponse.json();

            // 2. Load the mapping JSON
            const mappingResponse = await fetch(`LESSON/${lesson.mapping}`);
            if (!mappingResponse.ok) throw new Error(`Kh√¥ng th·ªÉ t·∫£i file mapping: ${mappingResponse.status}`);
            const mappingData = await mappingResponse.json();

            // 3. Parse script lines from your specific format
            const scriptLines = this.parseLessonData(lessonData, mappingData);
            
            if (scriptLines.length === 0) {
              throw new Error('Kh√¥ng c√≥ d·ªØ li·ªáu h·ªôi tho·∫°i h·ª£p l·ªá');
            }

            const totalPairs = Math.floor(scriptLines.length / 2);
            
            // Reset accuracy stats for new session
            this.state.accuracyStats = {
              totalAttempts: 0,
              successful: 0,
              failed: 0,
              accuracy: 0,
              sessionAccuracy: 0,
              commonErrors: []
            };
            
            // 4. Set state with loaded lesson
            this.setState({
              currentLesson: lesson,
              scriptLines: scriptLines,
              originalScriptLines: scriptLines,
              audioBasePath: `LESSON/${lesson.audio}`,
              currentIndex: 0,
              currentPair: 1,
              totalPairs: totalPairs,
              appState: 'PLAYING',
              feedback: { type: 'success', message: '' },
              isAutoPlaying: false,
              transcript: '',
              isShadowingActive: this.state.userRole === 'AB',
              attempts: 0,
              matchingThreshold: this.getMatchingThreshold()
            });

            // 5. Preload first few audio files
            this.preloadAudioFiles(scriptLines.slice(0, 4));


          } catch (error) {
            console.error('L·ªói t·∫£i b√†i h·ªçc:', error);
            this.setState({
              appState: 'SETUP',
              feedback: { type: 'error', message: `L·ªói: ${error.message}` }
            });
          }
        }

        // Parse your specific format: each item is [EN, IPA, VI, Example_EN, Example_IPA, Example_VI]
        parseLessonData(lessonData, mappingData) {
          const scriptLines = [];
          const mappingDict = {};
          
          // Create a dictionary for quick audio file lookup
          mappingData.forEach(item => {
            mappingDict[item.text] = item.file;
          });

          // Process each lesson item (each is an array of 6 elements)
          lessonData.forEach((item, index) => {
            if (item.length >= 6) {
              const englishText = item[0];
              const ipaText = item[1];
              const vietnameseText = item[2];
              const exampleEnglish = item[3];
              const exampleIpa = item[4];
              const exampleVietnamese = item[5];
              
              // Add the main question as role A
              scriptLines.push({
                id: `line-${index}-q`,
                role: 'A',
                text: englishText,
                ipa: ipaText,
                translation: vietnameseText,
                audioFile: mappingDict[englishText] ? `LESSON/${mappingDict[englishText]}` : null,
                lineIndex: index * 2,
                pairNumber: index + 1
              });
              
              // Add the example response as role B
              scriptLines.push({
                id: `line-${index}-a`,
                role: 'B',
                text: exampleEnglish,
                ipa: exampleIpa,
                translation: exampleVietnamese,
                audioFile: mappingDict[exampleEnglish] ? `LESSON/${mappingDict[exampleEnglish]}` : null,
                lineIndex: index * 2 + 1,
                pairNumber: index + 1
              });
            }
          });
          
          return scriptLines;
        }

        async preloadAudioFiles(lines) {
          for (const line of lines) {
            if (line.audioFile && !this.state.audioCache.has(line.audioFile)) {
              try {
                const audioBuffer = await this.loadAudioFile(line.audioFile);
                this.state.audioCache.set(line.audioFile, audioBuffer);
              } catch (error) {
                console.warn(`Kh√¥ng th·ªÉ t·∫£i tr∆∞·ªõc: ${line.audioFile}`, error);
              }
            }
          }
        }

        async loadAudioFile(url) {
          try {
            const response = await fetch(url);
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const arrayBuffer = await response.arrayBuffer();
            const audioContext = this.getAudioContext();
            return await audioContext.decodeAudioData(arrayBuffer);
          } catch (error) {
            console.error('L·ªói t·∫£i audio:', error);
            throw error;
          }
        }

        // --- PLAYBACK LOGIC ---
        async processCurrentLine() {
          if (this.state.appState !== 'PLAYING' || !this.state.isAutoPlaying) return;

          const currentLine = this.state.scriptLines[this.state.currentIndex];
          
          if (!currentLine) {
            // End of lesson - loop back
            this.setState({
              currentIndex: 0,
              currentPair: 1,
              feedback: { type: 'success', message: 'Ho√†n th√†nh tua! B·∫Øt ƒë·∫ßu l·∫°i t·ª´ ƒë·∫ßu...' }
            });
            // Continue if still auto playing
            if (this.state.isAutoPlaying) {
              setTimeout(() => this.processCurrentLine(), 2000);
            }
            return;
          }

          // Update current pair
          this.setState({ currentPair: Math.floor(this.state.currentIndex / 2) + 1 });

          // Determine if it's AI's turn or user's turn
          const isUsersTurn = this.state.userRole === 'AB' ? true : currentLine.role === this.state.userRole;
          
          if (!isUsersTurn) {
            // AI speaks (play audio)
            this.setState({
              feedback: { 
                type: 'neutral', 
                message: `ƒêang nghe ${currentLine.role === 'A' ? 'Ng∆∞·ªùi A' : 'Ng∆∞·ªùi B'} n√≥i...` 
              },
              isProcessingAI: true
            });

            try {
              if (currentLine.audioFile) {
                await this.playAudio(currentLine.audioFile);
              } else {
                // Fallback: speak text using selected voice1
                await this.speakText(currentLine.text || '', this.state.voice1 || 'gTTS');
              }
              
              // Move to next line after playback
              this.setState({
                isProcessingAI: false,
                currentIndex: this.state.currentIndex + 1,
                currentPair: Math.floor((this.state.currentIndex + 1) / 2) + 1
              });
              
              // Process next line after delay
              setTimeout(() => this.processCurrentLine(), 300);
              
            } catch (error) {
              console.error('L·ªói ph√°t √¢m thanh:', error);
              this.setState({
                feedback: { type: 'error', message: 'L·ªói ph√°t √¢m thanh. Chuy·ªÉn sang d√≤ng ti·∫øp theo...' },
                isProcessingAI: false,
                currentIndex: this.state.currentIndex + 1,
                currentPair: Math.floor((this.state.currentIndex + 1) / 2) + 1
              });
              setTimeout(() => this.processCurrentLine(), 1000);
            }
          } else {
            // User's turn to speak (for both normal and shadowing modes)
            if (this.state.userRole === 'AB') {
              // Shadowing mode: user speaks immediately after hearing
              this.setState({
                feedback: { 
                  type: 'neutral', 
                  message: 'SHADOWING: L·∫∑p l·∫°i ngay sau khi nghe!' 
                },
                transcript: ''
              });

              // In shadowing mode, start listening immediately with a prompt
              setTimeout(() => {
                if (this.state.isAutoPlaying && this.speechRecognition) {
                  if (!this.state.isListening) {
                    try {
                      this.speechRecognition.start();
                    } catch (e) {
                      console.warn('Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu nh·∫≠n di·ªán:', e);
                      // Auto-advance if speech recognition fails
                      setTimeout(() => {
                        this.setState({
                          currentIndex: this.state.currentIndex + 1,
                          currentPair: Math.floor((this.state.currentIndex + 1) / 2) + 1,
                          feedback: { type: 'error', message: 'L·ªói microphone. T·ª± ƒë·ªông chuy·ªÉn ti·∫øp...' }
                        });
                        this.processCurrentLine();
                      }, 1500);
                    }
                  } else {
                    console.warn('SpeechRecognition already running, skip start');
                  }
                }
              }, this.state.shadowDelay);
              
              // Also play the audio for shadowing
              setTimeout(async () => {
                if (currentLine.audioFile) {
                  try {
                    await this.playAudio(currentLine.audioFile);
                  } catch (error) {
                    console.error('L·ªói ph√°t audio shadowing:', error);
                  }
                }
              }, 100);
              } else {
              // Normal mode
              this.setState({
                feedback: { 
                  type: 'neutral', 
                  message: '' 
                },
                transcript: '',
                waitingForUser: true
              });

              // Start listening after delay
              setTimeout(() => {
                if (this.state.isAutoPlaying && this.speechRecognition) {
                  if (!this.state.isListening) {
                    try {
                      this.speechRecognition.start();
                    } catch (e) {
                      console.warn('Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu nh·∫≠n di·ªán:', e);
                      // Auto-advance if speech recognition fails
                      setTimeout(() => {
                        this.setState({
                          currentIndex: this.state.currentIndex + 1,
                          currentPair: Math.floor((this.state.currentIndex + 1) / 2) + 1,
                          feedback: { type: 'error', message: 'L·ªói microphone. T·ª± ƒë·ªông chuy·ªÉn ti·∫øp...' }
                        });
                        this.processCurrentLine();
                      }, 1500);
                    }
                  } else {
                    console.warn('SpeechRecognition already running, skip start');
                  }
                }
              }, this.state.userReplyDelay || 50);
            }
          }
        }

        async playAudio(audioFile) {
          try {
            let audioBuffer = this.state.audioCache.get(audioFile);
            
            if (!audioBuffer) {
              audioBuffer = await this.loadAudioFile(audioFile);
              this.state.audioCache.set(audioFile, audioBuffer);
            }
            
            const audioContext = this.getAudioContext();
            const source = audioContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(audioContext.destination);
            
            return new Promise((resolve) => {
              source.onended = resolve;
              source.start();
            });
          } catch (error) {
            console.error('L·ªói ph√°t audio:', error);
            throw error;
          }
        }

        // Replay the current line's audio/text without requiring auto-play
        async replayCurrentLine() {
          try {
            const currentLine = this.state.scriptLines[this.state.currentIndex];
            if (!currentLine) return;
            if (currentLine.audioFile) {
              await this.playAudio(currentLine.audioFile);
            } else if (currentLine.text) {
              await this.speakText(currentLine.text || '', this.state.voice1 || 'gTTS');
            }
          } catch (e) { console.warn('replayCurrentLine failed', e); }
        }

            // Play sample for the user's selected role (A or B) in the current pair
            async playPartnerSample() {
              try {
                const lines = this.state.scriptLines || [];
                const idx = this.state.currentIndex || 0;
                const userRole = this.state.userRole || 'A';

                // determine target line index that corresponds to the user's role within the current pair
                let targetIdx = idx;
                if (!lines[targetIdx] || lines[targetIdx].role !== userRole) {
                  const pairStart = Math.floor(idx / 2) * 2;
                  const c1 = lines[pairStart];
                  const c2 = lines[pairStart + 1];
                  if (c1 && c1.role === userRole) targetIdx = pairStart;
                  else if (c2 && c2.role === userRole) targetIdx = pairStart + 1;
                  else {
                    // fallback: search nearby for the next line with the role
                    const found = lines.findIndex((l, i) => (i >= pairStart && i <= pairStart + 1) && l.role === userRole);
                    if (found >= 0) targetIdx = found;
                  }
                }

                if (targetIdx < 0 || targetIdx >= lines.length) return;
                const targetLine = lines[targetIdx];
                if (!targetLine) return;

                // Temporarily stop RolePlay recognition and global recognition to avoid capturing playback
                const rpRec = this.speechRecognition;
                const rpWasListening = !!this.state.isListening;
                try { if (rpRec && typeof rpRec.stop === 'function') { try { rpRec.stop(); } catch(e){} } } catch(e){}

                const gRec = window.recognition;
                const gWasRunning = !!window.isRecognitionRunning;
                try { if (gRec && typeof gRec.stop === 'function') { try { gRec.stop(); } catch(e){} } } catch(e){}

                // Play the user's role sample (so learner can hear and repeat)
                if (targetLine.audioFile) {
                  await this.playAudio(targetLine.audioFile);
                } else if (targetLine.text) {
                  await this.speakText(targetLine.text || '', this.state.voice1 || 'gTTS');
                }

                // Resume recognizers only if they were running before playback
                try { if (rpRec && rpWasListening && typeof rpRec.start === 'function') { try { rpRec.start(); } catch(e){} } } catch(e){}
                try { if (gRec && gWasRunning && typeof gRec.start === 'function') { try { gRec.start(); } catch(e){} } } catch(e){}

              } catch (e) { console.warn('playPartnerSample failed', e); }
            }

        // Speak text using Web Speech Synthesis as fallback TTS
        speakText(text, engine = 'gTTS') {
          return new Promise((resolve) => {
            try {
              const synth = window.speechSynthesis;
              if (!synth) {
                // no TTS support; fallback to short delay
                setTimeout(resolve, 1000);
                return;
              }

              let voices = synth.getVoices();
              // getVoices can be empty initially; if so, wait briefly
              if (!voices || voices.length === 0) {
                // try again after voices loaded
                synth.onvoiceschanged = () => {
                  voices = synth.getVoices() || [];
                  const selected = this.selectVoiceByEngine(voices, engine);
                  const utter = new SpeechSynthesisUtterance(text);
                  if (selected) utter.voice = selected;
                  utter.rate = 1;
                  utter.onend = resolve;
                  synth.speak(utter);
                };
                // safety timeout
                setTimeout(() => resolve(), 1500);
                return;
              }

              const selected = this.selectVoiceByEngine(voices, engine);
              const utter = new SpeechSynthesisUtterance(text);
              if (selected) utter.voice = selected;
              utter.rate = 1;
              utter.onend = resolve;
              synth.speak(utter);
            } catch (e) {
              console.warn('TTS l·ªói, d√πng ch·ªù thay th·∫ø', e);
              setTimeout(resolve, 1000);
            }
          });
        }

        selectVoiceByEngine(voices, engine) {
          // engine: 'gTTS' -> prefer Google-like female en-US; 'Edge' -> prefer Microsoft/ male
          const enVoices = voices.filter(v => v.lang && v.lang.startsWith('en'));
          if (engine === 'Edge') {
            // prefer voices with "Microsoft" or male hints
            let v = enVoices.find(vv => /Microsoft|Zira|Male|Guy|Adam/i.test(vv.name));
            if (v) return v;
            // fallback to any en voice
            return enVoices[0] || voices[0];
          }
          // default gTTS-like: prefer Google voices or female names
          let v = enVoices.find(vv => /Google|Female|Samantha|Emma|Alloy/i.test(vv.name));
          if (v) return v;
          // fallback to first en voice
          return enVoices[0] || voices[0];
        }

        // --- CONTROLS ---
        toggleAutoPlay() {
          const newState = !this.state.isAutoPlaying;
          this.setState({ isAutoPlaying: newState });
          
          if (newState && this.state.appState === 'PLAYING') {
            // Reset to beginning if at end
            if (this.state.currentIndex >= this.state.scriptLines.length) {
              this.setState({ currentIndex: 0, currentPair: 1 });
            }
            if (!this.state.isListening) {
              this.processCurrentLine();
            }
          } else if (!newState && this.speechRecognition) {
            this.speechRecognition.stop();
          }
        }

        stopPractice() {
          if (this.speechRecognition) this.speechRecognition.abort();
          if (this.audioContext) {
            this.audioContext.close();
            this.audioContext = null;
          }
          
          this.setState({
            appState: 'SETUP',
            isAutoPlaying: false,
            isProcessingAI: false,
            isListening: false,
            feedback: { type: 'neutral', message: 'ƒê√£ d·ª´ng. Ch·ªçn b√†i h·ªçc m·ªõi.' },
            currentPair: 1,
            isShadowingActive: false
          });
        }

        selectLesson(index) {
          this.setState({ selectedLessonIndex: index });
        }

        startRangeSession() {
          const start = parseInt(document.getElementById('rangeStart').value);
          const end = parseInt(document.getElementById('rangeEnd').value);

          if (isNaN(start)) {
            this.setState({ feedback: { type: 'error', message: 'Vui l√≤ng nh·∫≠p c·∫∑p b·∫Øt ƒë·∫ßu' } });
            return;
          }
          
          if (isNaN(end)) {
            this.setState({ feedback: { type: 'error', message: 'Vui l√≤ng nh·∫≠p c·∫∑p k·∫øt th√∫c' } });
            return;
          }
          
          const totalPairs = Math.floor(this.state.scriptLines.length / 2);
          
          if (start < 1 || end < 1 || start > totalPairs || end > totalPairs) {
            this.setState({ feedback: { type: 'error', message: 'S·ªë c·∫∑p ph·∫£i l·ªõn h∆°n 0 v√† kh√¥ng v∆∞·ª£t qu√° t·ªïng s·ªë c·∫∑p' } });
            return;
          }
          
          if (start > end) {
            this.setState({ feedback: { type: 'error', message: 'C·∫∑p b·∫Øt ƒë·∫ßu ph·∫£i nh·ªè h∆°n c·∫∑p k·∫øt th√∫c' } });
            return;
          }
          
          const startLine = (start - 1) * 2;
          const endLine = end * 2;
          const sessionScriptLines = this.state.scriptLines.slice(startLine, endLine);
          
          if (sessionScriptLines.length === 0) {
            this.setState({ feedback: { type: 'error', message: 'Kh√¥ng c√≥ c·∫∑p n√†o trong kho·∫£ng n√†y' } });
            return;
          }
          
          this.setState({
            scriptLines: sessionScriptLines,
            startPair: start,
            endPair: end,
            currentIndex: 0,
            currentPair: 1,
            totalPairs: end - start + 1,
            appState: 'PLAYING',
            isShadowingActive: this.state.userRole === 'AB',
            feedback: { type: 'success', message: `B·∫Øt ƒë·∫ßu phi√™n h·ªçc t·ª´ c·∫∑p ${start} ƒë·∫øn ${end}` }
          });

          // Start playing if auto
          if (this.state.isAutoPlaying) {
            setTimeout(() => this.processCurrentLine(), 500);
          }
        }

        resetSession() {
          this.loadSelectedLesson();
          this.setState({ 
            startPair: null,
            endPair: null,
            feedback: { type: 'neutral', message: 'ƒê√£ reset phi√™n h·ªçc v·ªÅ to√†n b·ªô danh s√°ch' }
          });
        }

        setShadowDelay(delay) {
          this.setState({ shadowDelay: delay });
        }

        setDifficulty(difficulty) {
          this.setState({ 
            difficulty,
            matchingThreshold: this.getMatchingThreshold()
          });
        }

        // --- STATE MANAGEMENT ---
        setState(newState, skipRender = false) {
          this.state = { ...this.state, ...newState };
          // Clamp matchingThreshold to maximum 95% to avoid unrealistic 100%
          if (this.state.matchingThreshold > 0.95) {
            this.state.matchingThreshold = 0.95;
            this.state.customThreshold = true;
          }
          if (skipRender) {
            // If only transcript changed, update the interim transcript element to avoid full re-render
            if (Object.prototype.hasOwnProperty.call(newState, 'transcript')) {
              const interimEl = document.getElementById('interimTranscript');
              if (interimEl) {
                interimEl.textContent = newState.transcript || '';
              }
            }
            return;
          }
          this.render();
        }

        // --- RENDER ---
        render() {
          const app = document.getElementById('app');
          if (!app) return;

          const { 
            appState, userRole, currentIndex, feedback, isProcessingAI, 
            isAutoPlaying, transcript, isListening, availableLessons,
            scriptLines, originalScriptLines, currentLesson, selectedLessonIndex,
            startPair, endPair, currentPair, totalPairs, isShadowingActive, shadowDelay,
            difficulty, accuracyStats
          } = this.state;

          const isMicSupported = this.speechRecognition !== null;
          const hasLessons = availableLessons.length > 0;
          const displayTotalPairs = startPair && endPair ? (endPair - startPair + 1) : Math.floor(scriptLines.length / 2);

          // Generate progress steps (max 10 steps for visibility)
          const progressSteps = [];
          const maxSteps = 10;
          const stepInterval = Math.max(1, Math.floor(displayTotalPairs / maxSteps));
          
          for (let i = 1; i <= displayTotalPairs; i += stepInterval) {
            if (progressSteps.length < maxSteps) {
              progressSteps.push(i);
            }
          }
          if (progressSteps[progressSteps.length - 1] !== displayTotalPairs) {
            progressSteps.push(displayTotalPairs);
          }

          const accuracyColor = this.getAccuracyColor(accuracyStats.accuracy);
          const waitingClass = (isListening || this.state.waitingForUser) ? ' waiting' : '';
          const sessionAccuracyColor = this.getAccuracyColor(accuracyStats.sessionAccuracy);

          app.innerHTML = `
            <div class="roleplay-container">
              <main>
                ${scriptLines[currentIndex] && scriptLines[currentIndex].text ? `
                  <div class="exercise-item">
                    <div class="question">${scriptLines[currentIndex].text}</div>
                    ${scriptLines[currentIndex].ipa ? `<div id="rp_ipa">${scriptLines[currentIndex].ipa}</div>` : ''}
                    ${scriptLines[currentIndex].translation ? `<div id="rp_vn">${scriptLines[currentIndex].translation}</div>` : ''}
                    <div id="feedbackBox" class="feedback${waitingClass}">${(feedback.type==='success' || feedback.type==='error') ? feedback.message : ''}
                      <div id="interimTranscript" class="transcript-interim">${transcript ? transcript : ''}</div>
                    </div>
                  </div>
                ` : `
                  <div class="rp-placeholder">Ch·ªçn b√†i h·ªçc v√† nh·∫•n B·∫Øt ƒë·∫ßu</div>
                `}
              </main>

              <div class="control-panel rp-control">
                <div class="rp-row">
                  <select id="appLessonSelect">
                    <option value="">-- Ch·ªçn b√†i h·ªçc --</option>
                    ${availableLessons.map((l, i) => `<option value="${i}" ${selectedLessonIndex===i? 'selected':''}>${l.name.replace('.json','')}</option>`).join('')}
                  </select>
                  <select id="voice_ctrl">
                    <option value="gTTS" ${this.state.voice1 === 'gTTS' ? 'selected' : ''}>gTTS (Female)</option>
                    <option value="Edge" ${this.state.voice1 === 'Edge' ? 'selected' : ''}>Edge (Male)</option>
                  </select>
                  <button id="rpSaveBookmark" class="btn ghost" title="L∆∞u bookmark">üîñ L∆∞u</button>
                  <button id="rpLoadBookmark" class="btn ghost" title="T·∫£i bookmark">üìÇ T·∫£i</button>
                </div>

                <div class="rp-row rp-options">
                  <div class="option-group">
                    <label>Ch·∫ø ƒë·ªô:</label>
                    <button id="roleA" class="btn ghost ${userRole==='A' ? 'active-mode':''}">Vai A</button>
                    <button id="roleB" class="btn ghost ${userRole==='B' ? 'active-mode':''}">Vai B</button>
                  </div>

                  <div class="option-group">
                    <label>Ng∆∞·ª°ng:</label>
                    <input id="matchingThreshold" type="range" min="0" max="95" value="${Math.min(Math.round(this.state.matchingThreshold*100),95)}" />
                    <span id="matchingThresholdValue">${Math.min(Math.round(this.state.matchingThreshold*100),95)}%</span>
                  </div>

                  <div class="option-group">
                    <label>Reply delay:</label>
                    <input id="replyDelayCtrl" type="range" min="50" max="2000" step="25" value="${this.state.userReplyDelay || 50}" />
                    <span id="replyDelayVal">${(this.state.userReplyDelay || 50)}ms</span>
                  </div>

                  <div class="option-group">
                    <label>Phi√™n (s·ªë c·∫∑p):</label>
                    <input id="sessionPairsCount" type="number" min="1" value="${displayTotalPairs}" />
                    <button id="applySessionPairsBtn" class="btn ghost">√Åp d·ª•ng Phi√™n</button>
                  </div>

                  <div class="spacer"></div>
                </div>
              </div>

              <footer class="rp-footer">RolePlay AI ‚Ä¢ giao di·ªán A1-style</footer>
            </div>
          `;

          // Add concise progress info below the main card (outside the exercise-item)
          try {
            const overallTotal = (originalScriptLines && originalScriptLines.length) ? Math.floor(originalScriptLines.length/2) : displayTotalPairs;
            let rpInfo = document.getElementById('rpPageInfo');
            const mainEl = app.querySelector('main') || app;
            if (!rpInfo) {
              rpInfo = document.createElement('div');
              rpInfo.id = 'rpPageInfo';
              rpInfo.className = 'rp-page-info';
              mainEl.appendChild(rpInfo);
            }
            rpInfo.textContent = `${currentPair} / ${displayTotalPairs} (t·ªïng ${overallTotal})`;
          } catch (e) { console.warn('rp progress render failed', e); }

          this.attachEventListeners();
        }

        attachEventListeners() {
          // Store app instance in window for inline event handlers
          window.app = this;

          // Role selection
          document.getElementById('roleA')?.addEventListener('click', () => this.setState({ userRole: 'A' }));
          document.getElementById('roleB')?.addEventListener('click', () => this.setState({ userRole: 'B' }));
          // Voice selector (single control)
          document.getElementById('voice_ctrl')?.addEventListener('change', (e) => this.setState({ voice1: e.target.value }));
          // Lesson select in header
          document.getElementById('appLessonSelect')?.addEventListener('change', (e) => {
            const v = parseInt(e.target.value, 10);
            if (!isNaN(v)) {
              this.setState({ selectedLessonIndex: v });
              // update main lessonSelect UI to reflect selection (without triggering its change handler)
              try {
                if (typeof lessonSelect !== 'undefined' && lessonSelect) {
                  lessonSelect.value = 'remote:' + v;
                  // dispatch change so main handler picks up and syncs other tabs
                  lessonSelect.dispatchEvent(new Event('change', { bubbles: true }));
                }
              } catch(e) { /* ignore */ }
              // immediately load the selected lesson into RolePlay
              try { if (typeof this.loadSelectedLesson === 'function') this.loadSelectedLesson(); } catch (e) { console.warn('appLessonSelect loadSelectedLesson failed', e); }
            }
          });
          // playSample and listenBtn removed from RolePlay UI

          // Reply delay control (slider)
          const replyCtrl = document.getElementById('replyDelayCtrl');
          const replyVal = document.getElementById('replyDelayVal');
          if (replyCtrl) {
            replyCtrl.addEventListener('input', (e) => {
              const ms = parseInt(e.target.value, 10) || 0;
              // update both shadowDelay and userReplyDelay
              this.setState({ shadowDelay: ms, userReplyDelay: ms });
              if (replyVal) replyVal.textContent = ms + 'ms';
            });
          }

          // Reset preset button (difficulty presets removed)
          document.getElementById('resetPresetBtn')?.addEventListener('click', () => {
            this.setState({ customThreshold: false, matchingThreshold: this.getMatchingThreshold() });
          });

          // Matching threshold slider (0-100%)
          const matchingInput = document.getElementById('matchingThreshold');
          const matchingValue = document.getElementById('matchingThresholdValue');
          if (matchingInput) {
            matchingInput.addEventListener('input', (e) => {
              let v = parseInt(e.target.value || '0', 10);
              // enforce maximum 95%
              if (v > 95) v = 95;
              this.setState({ matchingThreshold: v / 100, customThreshold: true });
              if (matchingValue) matchingValue.textContent = `${v}%`;
              const warn = document.getElementById('matchingThresholdWarn');
              if (warn) {
                if (v >= 95) {
                  warn.textContent = 'C·∫£nh b√°o: Ng∆∞·ª°ng ‚â•95% ƒë√£ b·ªã gi·ªõi h·∫°n ‚Äî gi√° tr·ªã t·ªëi ƒëa cho ph√©p l√† 95%.';
                  warn.className = 'text-xs mt-1 text-yellow-400';
                } else {
                  warn.textContent = 'Khuy·∫øn ngh·ªã: 90‚Äì95% l√† m·ª©c c√¢n b·∫±ng gi·ªØa ch√≠nh x√°c v√† t√≠nh th·ª±c t·∫ø.';
                  warn.className = 'text-xs mt-1 text-gray-500';
                }
              }
              // ensure the slider reflects clamped value
              matchingInput.value = String(v);
            });
          }

          // Start button removed; central Play controls RolePlay playback

          // Range session buttons
          document.getElementById('startRangeBtn')?.addEventListener('click', () => this.startRangeSession());
          document.getElementById('resetSessionBtn')?.addEventListener('click', () => this.resetSession());

          // Apply session pairs (start from current pair)
          document.getElementById('applySessionPairsBtn')?.addEventListener('click', () => {
            try {
              const raw = document.getElementById('sessionPairsCount')?.value;
              let count = parseInt(raw, 10);
              if (isNaN(count) || count < 1) {
                this.setState({ feedback: { type: 'error', message: 'S·ªë c·∫∑p kh√¥ng h·ª£p l·ªá' } });
                return;
              }
              const startPair = this.state.currentPair && this.state.currentPair > 0 ? this.state.currentPair : 1;
              const endPair = startPair + count - 1;

              const startLine = (startPair - 1) * 2;
              const endLine = endPair * 2; // slice end is exclusive

              const fullLines = (this.state.originalScriptLines && this.state.originalScriptLines.length) ? this.state.originalScriptLines : this.state.scriptLines;
              const sliced = fullLines.slice(startLine, endLine);
              if (!sliced || sliced.length === 0) {
                this.setState({ feedback: { type: 'error', message: 'Kh√¥ng ƒë·ªß c√¢u trong b√†i ƒë·ªÉ t·∫°o phi√™n' } });
                return;
              }

              this.setState({
                scriptLines: sliced,
                startPair: startPair,
                endPair: endPair,
                currentIndex: 0,
                currentPair: 1,
                totalPairs: count,
                appState: 'PLAYING',
                isAutoPlaying: false,
                feedback: { type: 'success', message: `Phi√™n: ${startPair} ‚Üí ${endPair} (t·ªïng ${count} c·∫∑p)` }
              });
              // do not auto-start playing; user should press central Play
            } catch (e) { console.error(e); }
          });

          // Control buttons
          document.getElementById('toggleAutoPlay')?.addEventListener('click', () => this.toggleAutoPlay());
          // stopBtn removed; use central Play to toggle RolePlay playback

          // RolePlay: Save bookmark
          document.getElementById('rpSaveBookmark')?.addEventListener('click', () => {
            try {
              const lesson = this.state.currentLesson || this.state.availableLessons[this.state.selectedLessonIndex];
              if (!lesson) { this.setState({ feedback: { type: 'error', message: 'Ch∆∞a ch·ªçn b√†i ƒë·ªÉ l∆∞u bookmark' } }); return; }
              const key = `rp_bookmark_${lesson.name}`;
              const payload = {
                selectedLessonIndex: this.state.selectedLessonIndex,
                currentIndex: this.state.currentIndex,
                currentPair: this.state.currentPair,
                startPair: this.state.startPair,
                endPair: this.state.endPair,
                matchingThreshold: Math.round((this.state.matchingThreshold || 0) * 100),
                voice1: this.state.voice1,
                userRole: this.state.userRole,
                userReplyDelay: this.state.userReplyDelay || 50,
                ts: Date.now()
              };
              try { localStorage.setItem(key, JSON.stringify(payload)); localStorage.setItem('rp_last_bookmark', JSON.stringify({ key, payload })); } catch (e) { console.warn('save bk failed', e); }
              this.setState({ feedback: { type: 'success', message: 'ƒê√£ l∆∞u bookmark cho RolePlay' } });
            } catch (e) { console.error(e); this.setState({ feedback: { type: 'error', message: 'L∆∞u bookmark th·∫•t b·∫°i' } }); }
          });

          // RolePlay: Load bookmark
          document.getElementById('rpLoadBookmark')?.addEventListener('click', () => {
            try {
              const lesson = this.state.currentLesson || this.state.availableLessons[this.state.selectedLessonIndex];
              let key = null;
              if (lesson) key = `rp_bookmark_${lesson.name}`;
              let raw = key ? localStorage.getItem(key) : null;
              if (!raw) {
                const last = localStorage.getItem('rp_last_bookmark');
                if (last) {
                  try { const parsed = JSON.parse(last); raw = JSON.stringify(parsed.payload); }
                  catch(e){ raw = last; }
              }
              }
              if (!raw) { this.setState({ feedback: { type: 'error', message: 'Kh√¥ng t√¨m th·∫•y bookmark' } }); return; }
              const obj = JSON.parse(raw);
              // if lesson differs, switch lesson first
              if (typeof obj.selectedLessonIndex === 'number') {
                this.setState({ selectedLessonIndex: obj.selectedLessonIndex });
              }
              // load lesson and then restore indices after a short delay
              this.loadSelectedLesson().then?.(() => {}).catch(()=>{});
              setTimeout(() => {
                this.setState({
                  currentIndex: typeof obj.currentIndex === 'number' ? obj.currentIndex : (obj.currentPair ? ((obj.currentPair-1)*2) : 0),
                  currentPair: typeof obj.currentPair === 'number' ? obj.currentPair : 1,
                  startPair: typeof obj.startPair === 'number' ? obj.startPair : null,
                  endPair: typeof obj.endPair === 'number' ? obj.endPair : null,
                  matchingThreshold: (typeof obj.matchingThreshold === 'number') ? (obj.matchingThreshold/100) : this.state.matchingThreshold,
                  voice1: obj.voice1 || this.state.voice1,
                  userRole: obj.userRole || this.state.userRole,
                  userReplyDelay: typeof obj.userReplyDelay === 'number' ? obj.userReplyDelay : this.state.userReplyDelay
                });
                // ensure the app processes current line
                try { this.processCurrentLine(); } catch(e){}
                this.setState({ feedback: { type: 'success', message: 'ƒê√£ t·∫£i bookmark RolePlay' } });
              }, 600);
            } catch (e) { console.error(e); this.setState({ feedback: { type: 'error', message: 'T·∫£i bookmark th·∫•t b·∫°i' } }); }
          });

          // App selector removed
        }
      }

      // Initialize app immediately and also on DOMContentLoaded as a fallback
      try {
        if (!window.rolePlayInstance) window.rolePlayInstance = new RolePlayApp();
      } catch (e) { console.error('Failed to create RolePlayApp', e); }
      document.addEventListener('DOMContentLoaded', () => {
        try { if (!window.rolePlayInstance) window.rolePlayInstance = new RolePlayApp(); } catch (e) { console.error('Failed to create RolePlayApp on DOMContentLoaded', e); }
      });
    </script>
</body>
</html>